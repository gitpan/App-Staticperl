#!/bin/sh

#############################################################################
# configuration to fill in

STATICPERL=~/.staticperl
CPAN=http://mirror.netcologne.de/cpan/ # which mirror to use
EMAIL="read the documentation <rtfm@example.org>"

MKBUNDLE="$STATICPERL/mkbundle"

# perl build variables
PERL_PREFIX="$STATICPERL/perl" # where the perl gets installed
PERL_VERSION=5.12.2 # 5.8.9 is also a good choice
PERL_CONFIGURE="" # additional Configure arguments
PERL_CPPFLAGS="-DPERL_DISABLE_PMC -DPERL_ARENA_SIZE=65536 -D_GNU_SOURCE -DNDEBUG -USITELIB_EXP -USITEARCHEXP -UARCHLIB_EXP"
PERL_OPTIMIZE="-Os -ffunction-sections -fdata-sections -finline-limit=8 -ffast-math"

ARCH="$(uname -m)"

case "$ARCH" in
   i*86 | x86_64 | amd64 )
      PERL_OPTIMIZE="$PERL_OPTIMIZE -mpush-args -mno-inline-stringops-dynamically -mno-align-stringops -mno-ieee-fp" # x86/amd64
      case "$ARCH" in
         i*86 )
            PERL_OPTIMIZE="$PERL_OPTIMIZE -fomit-frame-pointer -march=pentium3 -mtune=i386" # x86 only
            ;;
      esac
      ;;
esac

# -Wl,--gc-sections makes it impossible to check for undefined references
# for some reason so we need to patch away the "-no" after Configure and before make :/
# -z muldefs is to work around uclibc's pthread static linking bug
PERL_LDFLAGS="-Wl,--no-gc-sections -z muldefs"
PERL_LIBS="-lm -lcrypt" # perl loves to add lotsa crap itself

# some configuration options for modules
export PERL_MM_USE_DEFAULT=1
#export CORO_INTERFACE=p # needed without nptl on x86, due to bugs in linuxthreads - very slow
export EV_EXTRA_DEFS='-DEV_FEATURES=4+8+16+64 -DEV_USE_SELECT=0 -DEV_USE_POLL=1 -DEV_USE_EPOLL=1 -DEV_NO_LOOPS -DEV_COMPAT3=0'

# which extra modules to install by default from CPAN that are
# required by mkbundle
STATICPERL_MODULES="common::sense Pod::Strip PPI::XS Pod::Usage"

# which extra modules you might want to install
EXTRA_MODULES=""

# overridable functions
preconfigure()  { : ; }
postconfigure() { : ; }
postbuild()     { : ; }
postinstall()   { : ; }

# now source user config, if any
[ -r /etc/staticperlrc ] && . /etc/staticperlrc
[ -r ~/.staticperlrc   ] && . ~/.staticperlrc
[ -r "$STATICPERL/rc"  ] && . "$STATICPERL/rc"

#############################################################################
# support

# set version in a way that Makefile.PL can extract
VERSION=VERSION; eval \
$VERSION=0.9

BZ2=bz2
BZIP2=bzip2

fatal() {
   printf -- "\nFATAL: %s\n\n" "$*" >&2
   exit 1
}

verbose() {
   printf -- "%s\n" "$*"
}

verblock() {
   verbose
   verbose "***"
   while read line; do
      verbose "*** $line"
   done
   verbose "***"
   verbose
}

rcd() {
   cd "$1" || fatal "$1: cannot enter"
}

trace() {
   prefix="$1"; shift
#   "$@" 2>&1 | while read line; do
#      echo "$prefix: $line"
#   done
   "$@"
}

trap wait 0

#############################################################################
# clean

distclean() {
   verblock <<EOF
deleting everything installed by this script
EOF

   rm -rf "$STATICPERL"
}

#############################################################################
# download/configure/compile/install perl

clean() {
   rm -rf "$STATICPERL/src/perl-$PERL_VERSION"
}

fetch() {
   rcd "$STATICPERL"

   mkdir -p src
   rcd src

   if ! [ -d "perl-$PERL_VERSION" ]; then
      if ! [ -e "perl-$PERL_VERSION.tar.$BZ2" ]; then

         URL="$CPAN/src/5.0/perl-$PERL_VERSION.tar.$BZ2"

         verblock <<EOF
downloading perl
to manually download perl yourself, place
perl-$PERL_VERSION.tar.$BZ2 in $STATICPERL
trying $URL
EOF

         rm -f perl-$PERL_VERSION.tar.$BZ2~ # just to be on the safe side
         wget -O perl-$PERL_VERSION.tar.$BZ2~ "$URL" \
            || curl >perl-$PERL_VERSION.tar.$BZ2~ "$URL" \
            || fatal "$URL: unable to download"
         mv perl-$PERL_VERSION.tar.$BZ2~ perl-$PERL_VERSION.tar.$BZ2
      fi

      verblock <<EOF
unpacking perl
EOF

      mkdir -p unpack
      $BZIP2 -d <perl-$PERL_VERSION.tar.bz2 | tar xC unpack \
         || fatal "perl-$PERL_VERSION.tar.bz2: error during unpacking"
      chmod -R u+w unpack/perl-$PERL_VERSION
      mv unpack/perl-$PERL_VERSION perl-$PERL_VERSION
      rmdir -p unpack
   fi
}

# similar to GNU-sed -i or perl -pi
sedreplace() {
   sed -e "$1" <"$2" > "$2~" || fatal "error while running sed"
   mv "$2~" "$2"
}

configure() {
   fetch

   rcd "$STATICPERL/src/perl-$PERL_VERSION"

   [ -e staticstamp.configure ] && return

   verblock <<EOF
configuring $STATICPERL/src/perl-$PERL_VERSION
EOF

   rm -f "$PERL_PREFIX/staticstamp.install"

   make distclean >/dev/null 2>&1

   # I hate them
   grep -q -- -fstack-protector Configure && \
      sedreplace 's/-fstack-protector/-fno-stack-protector/g' Configure

   preconfigure

#   trace configure \
   sh Configure -Duselargefiles \
                -Uuse64bitint \
                -Dusemymalloc=n \
                -Uusedl \
                -Uusethreads \
                -Uuseithreads \
                -Uusemultiplicity \
                -Duseperlio \
                -Uusesfio \
                -Uuseshrplib \
                -Dcppflags="$PERL_CPPFLAGS" \
                -Dccflags="-g2 -fno-strict-aliasing" \
                -Doptimize="$PERL_OPTIMIZE" \
                -Dldflags="$PERL_LDFLAGS" \
                -Dlibs="$PERL_LIBS" \
                -Dprefix="$PERL_PREFIX" \
                -Dbin="$PERL_PREFIX/bin" \
                -Dprivlib="$PERL_PREFIX/lib" \
                -Darchlib="$PERL_PREFIX/lib" \
                -Uusevendorprefix \
                -Dsitelib="$PERL_PREFIX/lib" \
                -Dsitearch="$PERL_PREFIX/lib" \
                -Usitelibexp \
                -Uman1dir \
                -Uman3dir \
                -Usiteman1dir \
                -Usiteman3dir \
                -Dpager=/usr/bin/less \
                -Demail="$EMAIL" \
                -Dcf_email="$EMAIL" \
                -Dcf_by="$EMAIL" \
                $PERL_CONFIGURE \
                -dE || fatal "Configure failed"

   sedreplace '
      s/-Wl,--no-gc-sections/-Wl,--gc-sections/g
      s/ *-fno-stack-protector */ /g
   ' config.sh

   sh Configure -S || fatal "Configure -S failed"

   postconfigure || fatal "postconfigure hook failed"

   touch staticstamp.configure
}

build() {
   configure

   rcd "$STATICPERL/src/perl-$PERL_VERSION"

   verblock <<EOF
building $STATICPERL/src/perl-$PERL_VERSION
EOF

   rm -f "$PERL_PREFIX/staticstamp.install"

   make || fatal "make: error while building perl"

   postbuild || fatal "postbuild hook failed"
}

install() {
   if ! [ -e "$PERL_PREFIX/staticstamp.install" ]; then
      build

      verblock <<EOF
installing $STATICPERL/src/perl-$PERL_VERSION
to $PERL_PREFIX
EOF

      rm -rf "$PERL_PREFIX"
      
      make install || fatal "make install: error while installing"

      rcd "$PERL_PREFIX"

      # create a "make install" replacement for CPAN
      cat >"$PERL_PREFIX"/bin/cpan-make-install <<EOF
make || exit

if find blib/arch/auto -type f | grep -q -v .exists; then
   echo Probably an XS module, rebuilding perl
   if make perl; then
      mv perl "$PERL_PREFIX"/bin/perl
      make -f Makefile.aperl map_clean
   else
      make -f Makefile.aperl map_clean
      exit 1
   fi
fi

make install UNINST=1
EOF
      chmod 755 "$PERL_PREFIX"/bin/cpan-make-install

      # trick CPAN into avoiding ~/.cpan completely
      echo 1 >"$PERL_PREFIX/lib/CPAN/MyConfig.pm"

      "$PERL_PREFIX"/bin/perl -MCPAN -e '
         CPAN::Shell->o (conf => urllist => push => "'"$CPAN"'");
         CPAN::Shell->o (conf => q<cpan_home>, "'"$STATICPERL"'/cpan");
         CPAN::Shell->o (conf => q<init>);
         CPAN::Shell->o (conf => q<cpan_home>, "'"$STATICPERL"'/cpan");
         CPAN::Shell->o (conf => q<build_dir>, "'"$STATICPERL"'/cpan/build");
         CPAN::Shell->o (conf => q<prefs_dir>, "'"$STATICPERL"'/cpan/prefs");
         CPAN::Shell->o (conf => q<histfile> , "'"$STATICPERL"'/cpan/histfile");
         CPAN::Shell->o (conf => q<keep_source_where>, "'"$STATICPERL"'/cpan/sources");
         CPAN::Shell->o (conf => q<make_install_make_command>, "'"$PERL_PREFIX"'/bin/cpan-make-install");
         CPAN::Shell->o (conf => q<prerequisites_policy>, q<follow>);
         CPAN::Shell->o (conf => q<build_requires_install_policy>, q<no>);
         CPAN::Shell->o (conf => q<commit>);
      ' || fatal "error while initialising CPAN"

      touch "$PERL_PREFIX/staticstamp.install"
   fi

   if ! [ -e "$PERL_PREFIX/staticstamp.postinstall" ]; then
      NOCHECK_INSTALL=+
      instcpan $STATICPERL_MODULES
      [ $EXTRA_MODULES ] && instcpan $EXTRA_MODULES

      postinstall || fatal "postinstall hook failed"

      touch "$PERL_PREFIX/staticstamp.postinstall"
   fi
}

#############################################################################
# install a module from CPAN

instcpan() {
   [ $NOCHECK_INSTALL ] || install

   verblock <<EOF
installing modules from CPAN
$@
EOF

   for mod in "$@"; do
      "$PERL_PREFIX"/bin/perl -MCPAN -e 'notest install => "'"$mod"'"' \
         || fatal "$mod: unable to install from CPAN"
   done
   rm -rf "$STATICPERL/build"
}

#############################################################################
# install a module from unpacked sources

instsrc() {
   [ $NOCHECK_INSTALL ] || install

   verblock <<EOF
installing modules from source
$@
EOF

   for mod in "$@"; do
      echo
      echo $mod
      (
         rcd $mod
         make -f Makefile.aperl map_clean >/dev/null 2>&1
         make distclean >/dev/null 2>&1
         "$PERL_PREFIX"/bin/perl Makefile.PL || fatal "$mod: error running Makefile.PL"
         make || fatal "$mod: error building module"
         "$PERL_PREFIX"/bin/cpan-make-install || fatal "$mod: error installing module"
         make distclean >/dev/null 2>&1
         exit 0
      ) || exit $?
   done
}

#############################################################################
# main

podusage() {
   echo
   if [ -e "$PERL_PREFIX/bin/perl" ]; then
      "$PERL_PREFIX/bin/perl" -MPod::Usage -e \
         'pod2usage -input => *STDIN, -output => *STDOUT, -verbose => '$1', -exitval => 0, -noperldoc => 1' <"$0" \
         2>/dev/null && exit
   fi
   # try whatever perl we can find
   perl -MPod::Usage -e \
      'pod2usage -input => *STDIN, -output => *STDOUT, -verbose => '$1', -exitval => 0, -noperldoc => 1' <"$0" \
      2>/dev/null && exit

   fatal "displaying documentation requires a working perl - try '$0 install' first"
}

usage() {
   podusage 0
}

catmkbundle() {
   {
      read dummy
      echo "#!$PERL_PREFIX/bin/perl"
      cat
   } <<'MKBUNDLE'
#!/opt/bin/perl

#############################################################################
# cannot load modules till after the tracer BEGIN block

our $VERBOSE  = 1;
our $STRIP    = "pod"; # none, pod or ppi
our $PERL     = 0;
our $APP;
our $VERIFY   = 0;
our $STATIC   = 0;

my $PREFIX  = "bundle";
my $PACKAGE = "static";

my %pm;
my %pmbin;
my @libs;
my @static_ext;
my $extralibs;

@ARGV
   or die "$0: use 'staticperl help' (or read the sources of staticperl)\n";

$|=1;

our ($TRACER_W, $TRACER_R);

sub find_inc($) {
   for (@INC) {
      next if ref;
      return $_ if -e "$_/$_[0]";
   }

   undef
}

BEGIN {
   # create a loader process to detect @INC requests before we load any modules
   my ($W_TRACER, $R_TRACER); # used by tracer

   pipe $R_TRACER, $TRACER_W or die "pipe: $!";
   pipe $TRACER_R, $W_TRACER or die "pipe: $!";

   unless (fork) {
      close $TRACER_R;
      close $TRACER_W;

      unshift @INC, sub {
         my $dir = find_inc $_[1]
            or return;

         syswrite $W_TRACER, "-\n$dir\n$_[1]\n";

         open my $fh, "<:perlio", "$dir/$_[1]"
            or warn "ERROR: $dir/$_[1]: $!\n";

         $fh
      };

      while (<$R_TRACER>) {
         if (/use (.*)$/) {
            my $mod = $1;
            eval "require $mod";
            warn "ERROR: $@ (while loading '$mod')\n"
               if $@;
            syswrite $W_TRACER, "\n";
         } elsif (/eval (.*)$/) {
            my $eval = $1;
            eval $eval;
            warn "ERROR: $@ (in '$eval')\n"
               if $@;
         }
      }

      exit 0;
   }
}

# module loading is now safe
use Config;

sub scan_al {
   my ($auto, $autodir, $ix) = @_;

   $pm{"$auto/$ix"} = "$autodir/$ix";

   open my $fh, "<:perlio", "$autodir/$ix"
      or die "$autodir/$ix: $!";

   my $package;

   while (<$fh>) {
      if (/^\s*sub\s+ ([^[:space:];]+) \s* (?:\([^)]*\))? \s*;?\s*$/x) {
         my $al = "auto/$package/$1.al";
         my $inc = find_inc $al;

         defined $inc or die "$al: autoload file not found, but should be there.\n";

         $pm{$al} = "$inc/$al";

      } elsif (/^\s*package\s+([^[:space:];]+)\s*;?\s*$/) {
         ($package = $1) =~ s/::/\//g;
      } elsif (/^\s*(?:#|1?\s*;?\s*$)/) {
         # nop
      } else {
         warn "$autodir/$ix: unparsable line, please report: $_";
      }
   }
}

sub trace_module {
   syswrite $TRACER_W, "use $_[0]\n";

   for (;;) {
      <$TRACER_R> =~ /^-$/ or last;
      my $dir  = <$TRACER_R>; chomp $dir;
      my $name = <$TRACER_R>; chomp $name;

      $pm{$name} = "$dir/$name";

      if ($name =~ /^(.*)\.pm$/) {
         my $auto    = "auto/$1";
         my $autodir = "$dir/$auto";

         if (-d $autodir) {
            opendir my $dir, $autodir
               or die "$autodir: $!\n";

            for (readdir $dir) {
               # AutoLoader
               scan_al $auto, $autodir, $_
                  if /\.ix$/;

               # static ext
               if (/\Q$Config{_a}\E$/o) {
                  push @libs, "$autodir/$_";
                  push @static_ext, $name;
               }

               # extralibs.ld
               if ($_ eq "extralibs.ld") {
                  open my $fh, "<:perlio", "$autodir/$_"
                     or die "$autodir/$_";

                  local $/;
                  $extralibs .= " " . <$fh>;
               }

               # dynamic object
               warn "WARNING: found shared object - can't link statically ($_)\n"
                  if /\.\Q$Config{dlext}\E$/o;
            }
         }
      }
   }
}

sub trace_eval {
   syswrite $TRACER_W, "eval $_[0]\n";
}

sub trace_finish {
   close $TRACER_W;
   close $TRACER_R;
}

#############################################################################
# now we can use modules

use common::sense;
use Digest::MD5;

sub dump_string {
   my ($fh, $data) = @_;

   if (length $data) {
      for (
         my $ofs = 0;
         length (my $substr = substr $data, $ofs, 80);
         $ofs += 80
      )  {
         $substr =~ s/([^\x20-\x21\x23-\x5b\x5d-\x7e])/sprintf "\\%03o", ord $1/ge;
         $substr =~ s/\?/\\?/g; # trigraphs...
         print $fh "  \"$substr\"\n";
      }
   } else {
      print $fh "  \"\"\n";
   }
}

# required for @INC loading, unfortunately
trace_module "PerlIO::scalar";

#trace_module "Term::ReadLine::readline"; # Term::ReadLine::Perl dependency
# URI is difficult
#trace_module "URI::http";
#trace_module "URI::_generic";

sub cmd_boot {
   $pm{"//boot"} = $_[0];
}

sub cmd_add {
   $_[0] =~ /^(.*)(?:\s+(\S+))$/
      or die "$_[0]: cannot parse";

   my $file = $1;
   my $as   = defined $2 ? $2 : "/$1";

   $pm{$as} = $file;
   $pmbin{$as} = 1 if $_[1];
}

sub cmd_file {
   open my $fh, "<", $_[0]
      or die "$_[0]: $!\n";

   while (<$fh>) {
      chomp;
      my ($cmd, $args) = split / /, $_, 2;
      $cmd =~ s/^-+//;

      if ($cmd eq "strip") {
         $STRIP = $args;
      } elsif ($cmd eq "perl") {
         $PERL = 1;
      } elsif ($cmd eq "app") {
         $APP = $args;
      } elsif ($cmd eq "eval") {
         trace_eval $_;
      } elsif ($cmd eq "use") {
         trace_module $_
            for split / /, $args;
      } elsif ($cmd eq "boot") {
         cmd_boot $args;
      } elsif ($cmd eq "static") {
         $STATIC = 1;
      } elsif ($cmd eq "add") {
         cmd_add $args, 0;
      } elsif ($cmd eq "addbin") {
         cmd_add $args, 1;
      } elsif (/^\s*#/) {
         # comment
      } elsif (/\S/) {
         die "$_: unsupported directive\n";
      }
   }
}

use Getopt::Long;

Getopt::Long::Configure ("bundling", "no_auto_abbrev", "no_ignore_case");

GetOptions
   "strip=s"   => \$STRIP,
   "verbose|v" => sub { ++$VERBOSE },
   "quiet|q"   => sub { --$VERBOSE },
   "perl"      => \$PERL,
   "app=s"     => \$APP,
   "eval|e=s"  => sub { trace_eval   $_[1] },
   "use|M=s"   => sub { trace_module $_[1] },
   "boot=s"    => sub { cmd_boot     $_[1] },
   "add=s"     => sub { cmd_add      $_[1], 0 },
   "addbin=s"  => sub { cmd_add      $_[1], 1 },
   "static"    => sub { $STATIC = 1 },
   "<>"        => sub { cmd_file     $_[0] },
   or exit 1;

die "cannot specify both --app and --perl\n"
   if $PERL and defined $APP;

my $data;
my @index;
my @order = sort {
   length $a <=> length $b
      or $a cmp $b
} keys %pm;

# sorting by name - better compression, but needs more metadata
# sorting by length - faster lookup
# usually, the metadata overhead beats the loss through compression

for my $pm (@order) {
   my $path = $pm{$pm};

   128 > length $pm
      or die "$pm: path too long (only 128 octets supported)\n";

   my $src = ref $path
           ? $$path
           : do {
              open my $pm, "<", $path
                 or die "$path: $!";

              local $/;
              
              <$pm>
           };

   unless ($pmbin{$pm}) { # only do this unless the file is binary

      if ($pm =~ /^auto\/POSIX\/[^\/]+\.al$/) {
         if ($src =~ /^    unimpl \"/m) {
            warn "$pm: skipping (not implemented anyways).\n"
               if $VERBOSE >= 2;
            next;
         }
      }

      if ($STRIP =~ /ppi/i) {
         require PPI;

         my $ppi = PPI::Document->new (\$src);
         $ppi->prune ("PPI::Token::Comment");
         $ppi->prune ("PPI::Token::Pod");

         # prune END stuff
         for (my $last = $ppi->last_element; $last; ) {
            my $prev = $last->previous_token;

            if ($last->isa (PPI::Token::Whitespace::)) {
               $last->delete;
            } elsif ($last->isa (PPI::Statement::End::)) {
               $last->delete;
               last;
            } elsif ($last->isa (PPI::Token::Pod::)) {
               $last->delete;
            } else {
               last;
            }

            $last = $prev;
         }

         # prune some but not all insignificant whitespace
         for my $ws (@{ $ppi->find (PPI::Token::Whitespace::) }) {
            my $prev = $ws->previous_token;
            my $next = $ws->next_token;

            if (!$prev || !$next) {
               $ws->delete;
            } else {
               if (
                  $next->isa (PPI::Token::Operator::) && $next->{content} =~ /^(?:,|=|!|!=|==|=>)$/ # no ., because of digits. == float
                  or $prev->isa (PPI::Token::Operator::) && $prev->{content} =~ /^(?:,|=|\.|!|!=|==|=>)$/
                  or $prev->isa (PPI::Token::Structure::)
                  # decrease size, decrease compressability
                  #or ($prev->isa (PPI::Token::Word::)
                  #       && (PPI::Token::Symbol:: eq ref $next
                  #           || $next->isa (PPI::Structure::Block::)
                  #           || $next->isa (PPI::Structure::List::)
                  #           || $next->isa (PPI::Structure::Condition::)))
               ) {
                  $ws->delete;
               } elsif ($prev->isa (PPI::Token::Whitespace::)) {
                  $ws->{content} = ' ';
                  $prev->delete;
               } else {
                  $ws->{content} = ' ';
               }
            }
         }

         # prune whitespace around blocks
         if (0) {
            # these usually decrease size, but decrease compressability more
            for my $struct (PPI::Structure::Block::, PPI::Structure::Condition::) {
               for my $node (@{ $ppi->find ($struct) }) {
                  my $n1 = $node->first_token;
                  my $n2 = $n1->previous_token;
                  $n1->delete if $n1->isa (PPI::Token::Whitespace::);
                  $n2->delete if $n2 && $n2->isa (PPI::Token::Whitespace::);
                  my $n1 = $node->last_token;
                  my $n2 = $n1->next_token;
                  $n1->delete if $n1->isa (PPI::Token::Whitespace::);
                  $n2->delete if $n2 && $n2->isa (PPI::Token::Whitespace::);
               }
            }

            for my $node (@{ $ppi->find (PPI::Structure::List::) }) {
               my $n1 = $node->first_token;
               $n1->delete if $n1->isa (PPI::Token::Whitespace::);
               my $n1 = $node->last_token;
               $n1->delete if $n1->isa (PPI::Token::Whitespace::);
            }
         }

         # reformat qw() lists which often have lots of whitespace
         for my $node (@{ $ppi->find (PPI::Token::QuoteLike::Words::) }) {
            if ($node->{content} =~ /^qw(.)(.*)(.)$/s) {
               my ($a, $qw, $b) = ($1, $2, $3);
               $qw =~ s/^\s+//;
               $qw =~ s/\s+$//;
               $qw =~ s/\s+/ /g;
               $node->{content} = "qw$a$qw$b";
            }
         }

         $src = $ppi->serialize;
      } elsif ($STRIP =~ /pod/i && $pm ne "Opcode.pm") { # opcode parses it's own pod
         require Pod::Strip;

         my $stripper = Pod::Strip->new;

         my $out;
         $stripper->output_string (\$out);
         $stripper->parse_string_document ($src)
            or die;
         $src = $out;
      }

      if ($VERIFY && $pm =~ /\.pm$/ && $pm ne "Opcode.pm") {
         if (open my $fh, "-|") {
            <$fh>;
         } else {
            eval "#line 1 \"$pm\"\n$src" or warn "\n\n\n$pm\n\n$src\n$@\n\n\n";
            exit 0;
         }
      }

#      if ($pm eq "Opcode.pm") {
#         open my $fh, ">x" or die; print $fh $src;#d#
#         exit 1;
#      }
   }

   warn "adding $pm\n"
      if $VERBOSE >= 2;

   push @index, ((length $pm) << 25) | length $data;
   $data .= $pm . $src;
}

length $data < 2**25
   or die "bundle too large (only 32MB supported)\n";

my $varpfx = "bundle_" . substr +(Digest::MD5::md5_hex $data), 0, 16;

#############################################################################
# output

print "generating $PREFIX.h... ";

{
   open my $fh, ">", "$PREFIX.h"
      or die "$PREFIX.h: $!\n";

   print $fh <<EOF;
/* do not edit, automatically created by mkstaticbundle */

#include <EXTERN.h>
#include <perl.h>
#include <XSUB.h>

/* public API */
EXTERN_C PerlInterpreter *staticperl;
EXTERN_C void staticperl_xs_init (pTHX);
EXTERN_C void staticperl_init (void);
EXTERN_C void staticperl_cleanup (void);

EOF
}

print "\n";

#############################################################################
# output

print "generating $PREFIX.c... ";

open my $fh, ">", "$PREFIX.c"
   or die "$PREFIX.c: $!\n";

print $fh <<EOF;
/* do not edit, automatically created by mkstaticbundle */

#include "bundle.h"

/* public API */
PerlInterpreter *staticperl;

EOF

#############################################################################
# bundle data

my $count = @index;

print $fh <<EOF;
#include "bundle.h"

/* bundle data */

static const U32 $varpfx\_count = $count;
static const U32 $varpfx\_index [$count + 1] = {
EOF

my $col;
for (@index) {
   printf $fh "0x%08x,", $_;
   print $fh "\n" unless ++$col % 10;

}
printf $fh "0x%08x\n};\n", (length $data);

print $fh "static const char $varpfx\_data [] =\n";
dump_string $fh, $data;

print $fh ";\n\n";;

#############################################################################
# bootstrap

# boot file for staticperl
# this file will be eval'ed at initialisation time

my $bootstrap = '
BEGIN {
   package ' . $PACKAGE . ';

   PerlIO::scalar->bootstrap;

   @INC = sub {
      my $data = find "$_[1]"
         or return;

      $INC{$_[1]} = $_[1];

      open my $fh, "<", \$data;
      $fh
   };
}
';

$bootstrap .= "require '//boot';"
   if exists $pm{"//boot"};

$bootstrap =~ s/\s+/ /g;
$bootstrap =~ s/(\W) /$1/g;
$bootstrap =~ s/ (\W)/$1/g;

print $fh "const char bootstrap [] = ";
dump_string $fh, $bootstrap;
print $fh ";\n\n";

print $fh <<EOF;
/* search all bundles for the given file, using binary search */
XS(find)
{
  dXSARGS;

  if (items != 1)
    Perl_croak (aTHX_ "Usage: $PACKAGE\::find (\$path)");

  {
    STRLEN namelen;
    char *name = SvPV (ST (0), namelen);
    SV *res = 0;

    int l = 0, r = $varpfx\_count;

    while (l <= r)
      {
        int m = (l + r) >> 1;
        U32 idx = $varpfx\_index [m];
        int comp = namelen - (idx >> 25);

        if (!comp)
          {
            int ofs = idx & 0x1FFFFFFU;
            comp = memcmp (name, $varpfx\_data + ofs, namelen);

            if (!comp)
              {
                /* found */
                int ofs2 =  $varpfx\_index [m + 1] & 0x1FFFFFFU;

                ofs += namelen;
                res = newSVpvn ($varpfx\_data + ofs, ofs2 - ofs);
                goto found;
              }
          }

        if (comp < 0)
          r = m - 1;
        else
          l = m + 1;
      }

    XSRETURN (0);

  found:
    ST (0) = res;
    sv_2mortal (ST (0));
  }

  XSRETURN (1);
}

/* list all files in the bundle */
XS(list)
{
  dXSARGS;

  if (items != 0)
    Perl_croak (aTHX_ "Usage: $PACKAGE\::list");

  {
    int i;

    EXTEND (SP, $varpfx\_count);

    for (i = 0; i < $varpfx\_count; ++i)
      {
        U32 idx = $varpfx\_index [i];

        PUSHs (newSVpvn ($varpfx\_data + (idx & 0x1FFFFFFU), idx >> 25));
      }
  }

  XSRETURN ($varpfx\_count);
}

EOF

#############################################################################
# xs_init

print $fh <<EOF;
void
staticperl_xs_init (pTHX)
{
EOF

@static_ext = ("DynaLoader", sort @static_ext);

# prototypes
for (@static_ext) {
   s/\.pm$//;
   (my $cname = $_) =~ s/\//__/g;
   print $fh "  EXTERN_C void boot_$cname (pTHX_ CV* cv);\n";
}

print $fh <<EOF;
  char *file = __FILE__;
  dXSUB_SYS;

  newXSproto ("$PACKAGE\::find", find, file, "\$");
  newXSproto ("$PACKAGE\::list", list, file, "");
EOF

# calls
for (@static_ext) {
   s/\.pm$//;

   (my $cname = $_) =~ s/\//__/g;
   (my $pname = $_) =~ s/\//::/g;

   my $bootstrap = $pname eq "DynaLoader" ? "boot" : "bootstrap";

   print $fh "  newXS (\"$pname\::$bootstrap\", boot_$cname, file);\n";
}

print $fh <<EOF;
  Perl_av_create_and_unshift_one (&PL_preambleav, newSVpv (bootstrap, sizeof (bootstrap) - 1));
}
EOF

#############################################################################
# optional perl_init/perl_destroy

if ($APP) {
   print $fh <<EOF;

int
main (int argc, char *argv [])
{
  extern char **environ;
  int exitstatus;

  static char *args[] = {
    "staticperl",
    "-e",
    "0"
  };

  PERL_SYS_INIT3 (&argc, &argv, &environ);
  staticperl = perl_alloc ();
  perl_construct (staticperl);

  PL_exit_flags |= PERL_EXIT_DESTRUCT_END;

  exitstatus = perl_parse (staticperl, staticperl_xs_init, sizeof (args) / sizeof (*args), args, environ);
  if (!exitstatus)
    perl_run (staticperl);

  exitstatus = perl_destruct (staticperl);
  perl_free (staticperl);
  PERL_SYS_TERM ();

  return exitstatus;
}
EOF
} elsif ($PERL) {
   print $fh <<EOF;

int
main (int argc, char *argv [])
{
  extern char **environ;
  int exitstatus;

  PERL_SYS_INIT3 (&argc, &argv, &environ);
  staticperl = perl_alloc ();
  perl_construct (staticperl);

  PL_exit_flags |= PERL_EXIT_DESTRUCT_END;

  exitstatus = perl_parse (staticperl, staticperl_xs_init, argc, argv, environ);
  if (!exitstatus)
    perl_run (staticperl);

  exitstatus = perl_destruct (staticperl);
  perl_free (staticperl);
  PERL_SYS_TERM ();

  return exitstatus;
}
EOF
} else {
   print $fh <<EOF;

EXTERN_C void
staticperl_init (void)
{
  extern char **environ;
  int argc = sizeof (args) / sizeof (args [0]);
  char **argv = args;

  static char *args[] = {
    "staticperl",
    "-e",
    "0"
  };

  PERL_SYS_INIT3 (&argc, &argv, &environ);
  staticperl = perl_alloc ();
  perl_construct (staticperl);
  PL_origalen = 1;
  PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
  perl_parse (staticperl, staticperl_xs_init, argc, argv, environ);

  perl_run (staticperl);
}

EXTERN_C void
staticperl_cleanup (void)
{
  perl_destruct (staticperl);
  perl_free (staticperl);
  staticperl = 0;
  PERL_SYS_TERM ();
}
EOF
}

print -s "$PREFIX.c", " octets (", (length $data) , " data octets).\n\n";

#############################################################################
# libs, cflags

{
   print "generating $PREFIX.ccopts... ";

   my $str = "$Config{ccflags} $Config{optimize} $Config{cppflags} -I$Config{archlibexp}/CORE";
   $str =~ s/([\(\)])/\\$1/g;

   print "$str\n\n";

   open my $fh, ">$PREFIX.ccopts"
      or die "$PREFIX.ccopts: $!";
   print $fh $str;
}

{
   print "generating $PREFIX.ldopts... ";

   my $str = $STATIC ? "--static " : "";

   $str .= "$Config{ccdlflags} $Config{ldflags} @libs $Config{archlibexp}/CORE/$Config{libperl} $Config{perllibs}";

   my %seen;
   $str .= " $_" for grep !$seen{$_}++, ($extralibs =~ /(\S+)/g);

   $str =~ s/([\(\)])/\\$1/g;

   print "$str\n\n";

   open my $fh, ">$PREFIX.ldopts"
      or die "$PREFIX.ldopts: $!";
   print $fh $str;
}

if ($PERL or defined $APP) {
   $APP = "perl" unless defined $APP;

   print "generating $APP...\n";

   system "$Config{cc} \$(cat bundle.ccopts\) -o \Q$APP\E bundle.c \$(cat bundle.ldopts\)";

   unlink "$PREFIX.$_"
      for qw(ccopts ldopts c h);
}

MKBUNDLE
}

bundle() {
   catmkbundle >"$MKBUNDLE~" || fatal "$MKBUNDLE~: cannot create"
   chmod 755 "$MKBUNDLE~" && mv "$MKBUNDLE~" "$MKBUNDLE"
   "$PERL_PREFIX/bin/perl" -- "$MKBUNDLE" "$@"
}

if [ $# -gt 0 ]; then
   while [ $# -gt 0 ]; do
      mkdir -p "$STATICPERL" || fatal "$STATICPERL: cannot create"
      mkdir -p "$PERL_PREFIX" || fatal "$PERL_PREFIX: cannot create"

      command="${1#--}"; shift
      case "$command" in
         fetch | configure | build | install | clean | distclean)
            verblock <<EOF
$command
EOF
            ( "$command" )
            ;;
         instsrc )
            ( instsrc "$@" )
            exit
            ;;
         instcpan )
            ( instcpan "$@" )
            exit
            ;;
         cpan )
            ( install )
            "$PERL_PREFIX/bin/cpan" "$@"
            exit
            ;;
         mkbundle )
            ( install )
            bundle "$@"
            exit
            ;;
         mkperl )
            ( install )
            bundle --perl "$@"
            exit
            ;;
         mkapp )
            ( install )
            bundle --app "$@"
            exit
            ;;
         help )
            podusage 2
            ;;
         * )
            exec 1>&2
            echo
            echo "Unknown command: $command"
            podusage 0
            ;;
      esac
   done
else
   usage
fi

exit 0

=head1 NAME

staticperl - perl, libc, 100 modules, all in one 500kb file

=head1 SYNOPSIS

   staticperl help      # print the embedded documentation
   staticperl fetch     # fetch and unpack perl sources
   staticperl configure # fetch and then configure perl
   staticperl build     # configure and then build perl
   staticperl install   # build and then install perl
   staticperl clean     # clean most intermediate files (restart at configure)
   staticperl distclean # delete everything installed by this script
   staticperl cpan      # invoke CPAN shell
   staticperl instmod path...        # install unpacked modules
   staticperl instcpan modulename... # install modules from CPAN
   staticperl mkbundle <bundle-args...> # see documentation
   staticperl mkperl <bundle-args...>   # see documentation
   staticperl mkapp appname <bundle-args...> # see documentation

Typical Examples:

   staticperl install   # fetch, configure, build and install perl
   staticperl cpan      # run interactive cpan shell
   staticperl mkperl -M '"Config_heavy.pl"' # build a perl that supports -V
   staticperl mkperl -MAnyEvent::Impl::Perl -MAnyEvent::HTTPD -MURI -MURI::http
                        # build a perl with the above modules linked in
   staticperl mkapp myapp --boot mainprog mymodules
                        # build a binary "myapp" from mainprog and mymodules

=head1 DESCRIPTION

This script helps you creating single-file perl interpreters, or embedding
a perl interpreter in your applications. Single-file means that it is
fully self-contained - no separate shared objects, no autoload fragments,
no .pm or .pl files are needed. And when linking statically, you can
create (or embed) a single file that contains perl interpreter, libc, all
the modules you need and all the libraries you need.

With F<uClibc> and F<upx> on x86, you can create a single 500kb binary
that contains perl and 100 modules such as POSIX, AnyEvent, EV, IO::AIO,
Coro and so on. Or any other choice of modules.

The created files do not need write access to the file system (like PAR
does). In fact, since this script is in many ways similar to PAR::Packer,
here are the differences:

=over 4

=item * The generated executables are much smaller than PAR created ones.

Shared objects and the perl binary contain a lot of extra info, while
the static nature of F<staticperl> allows the linker to remove all
functionality and meta-info not required by the final executable. Even
extensions statically compiled into perl at build time will only be
present in the final executable when needed.

In addition, F<staticperl> can strip perl sources much more effectively
than PAR.

=item * The generated executables start much faster.

There is no need to unpack files, or even to parse Zip archives (which is
slow and memory-consuming business).

=item * The generated executables don't need a writable filesystem.

F<staticperl> loads all required files directly from memory. There is no
need to unpack files into a temporary directory.

=item * More control over included files.

PAR tries to be maintenance and hassle-free - it tries to include more
files than necessary to make sure everything works out of the box. The
extra files (such as the unicode database) can take substantial amounts of
memory and file size.

With F<staticperl>, the burden is mostly with the developer - only direct
compile-time dependencies and L<AutoLoader> are handled automatically.
This means the modules to include often need to be tweaked manually.

=item * PAR works out of the box, F<staticperl> does not.

Maintaining your own custom perl build can be a pain in the ass, and while
F<staticperl> tries to make this easy, it still requires a custom perl
build and possibly fiddling with some modules. PAR is likely to produce
results faster.

Ok, PAR never has worked for me out of the box, and for some people,
F<staticperl> does work out of the box, as they don't count "fiddling with
module use lists" against it, but nevertheless, F<staticperl> is certainly
a bit more difficult to use.

=back

=head1 HOW DOES IT WORK?

Simple: F<staticperl> downloads, compile and installs a perl version of
your choice in F<~/.staticperl>. You can add extra modules either by
letting F<staticperl> install them for you automatically, or by using CPAN
and doing it interactively. This usually takes 5-10 minutes, depending on
the speed of your computer and your internet connection.

It is possible to do program development at this stage, too.

Afterwards, you create a list of files and modules you want to include,
and then either build a new perl binary (that acts just like a normal perl
except everything is compiled in), or you create bundle files (basically C
sources you can use to embed all files into your project).

This step is very fast (a few seconds if PPI is not used for stripping,
more seconds otherwise, as PPI is very slow), and can be tweaked and
repeated as often as necessary.

=head1 THE F<STATICPERL> SCRIPT

This module installs a script called F<staticperl> into your perl
binary directory. The script is fully self-contained, and can be used
without perl (for example, in an uClibc chroot environment). In fact,
it can be extracted from the C<App::Staticperl> distribution tarball as
F<bin/staticperl>, without any installation.

F<staticperl> interprets the first argument as a command to execute,
optionally followed by any parameters.

There are two command categories: the "phase 1" commands which deal with
installing perl and perl modules, and the "phase 2" commands, which deal
with creating binaries and bundle files.

=head2 PHASE 1 COMMANDS: INSTALLING PERL

The most important command is F<install>, which does basically
everything. The default is to download and install perl 5.12.2 and a few
modules required by F<staticperl> itself, but all this can (and should) be
changed - see L<CONFIGURATION>, below.

The command

   staticperl install

Is normally all you need: It installs the perl interpreter in
F<~/.staticperl/perl>. It downloads, configures, builds and installs the
perl interpreter if required.

Most of the following commands simply run one or more steps of this
sequence.

To force recompilation or reinstallation, you need to run F<staticperl
distclean> first.

=over 4

=item F<staticperl fetch>

Runs only the download and unpack phase, unless this has already happened.

=item F<staticperl configure>

Configures the unpacked perl sources, potentially after downloading them first.

=item F<staticperl build>

Builds the configured perl sources, potentially after automatically
configuring them.

=item F<staticperl install>

Wipes the perl installation directory (usually F<~/.staticperl/perl>) and
installs the perl distribution, potentially after building it first.

=item F<staticperl cpan> [args...]

Starts an interactive CPAN shell that you can use to install further
modules. Installs the perl first if necessary, but apart from that,
no magic is involved: you could just as well run it manually via
F<~/.staticperl/perl/bin/cpan>.

Any additional arguments are simply passed to the F<cpan> command.

=item F<staticperl instcpan> module...

Tries to install all the modules given and their dependencies, using CPAN.

Example:

   staticperl instcpan EV AnyEvent::HTTPD Coro

=item F<staticperl instsrc> directory...

In the unlikely case that you have unpacked perl modules around and want
to install from these instead of from CPAN, you can do this using this
command by specifying all the directories with modules in them that you
want to have built.

=item F<staticperl clean>

Deletes the perl source directory (and potentially cleans up other
intermediate files). This can be used to clean up files only needed for
building perl, without removing the installed perl interpreter, or to
force a re-build from scratch.

At the moment, it doesn't delete downloaded tarballs.

=item F<staticperl distclean>

This wipes your complete F<~/.staticperl> directory. Be careful with this,
it nukes your perl download, perl sources, perl distribution and any
installed modules. It is useful if you wish to start over "from scratch"
or when you want to uninstall F<staticperl>.

=back

=head2 PHASE 2 COMMANDS: BUILDING PERL BUNDLES

Building (linking) a new F<perl> binary is handled by a separate
script. To make it easy to use F<staticperl> from a F<chroot>, the script
is embedded into F<staticperl>, which will write it out and call for you
with any arguments you pass:

   staticperl mkbundle mkbundle-args...

In the oh so unlikely case of something not working here, you
can run the script manually as well (by default it is written to
F<~/.staticperl/mkbundle>).

F<mkbundle> is a more conventional command and expect the argument
syntax commonly used on UNIX clones. For example, this command builds
a new F<perl> binary and includes F<Config.pm> (for F<perl -V>),
F<AnyEvent::HTTPD>, F<URI> and a custom F<httpd> script (from F<eg/httpd>
in this distribution):

   # first make sure we have perl and the required modules
   staticperl instcpan AnyEvent::HTTPD

   # now build the perl
   staticperl mkperl -M'"Config_heavy.pl"' -MAnyEvent::Impl::Perl \
                     -MAnyEvent::HTTPD -MURI::http \
                     --add 'eg/httpd httpd.pm'

   # finally, invoke it
   ./perl -Mhttpd

As you can see, things are not quite as trivial: the L<Config> module has
a hidden dependency which is not even a perl module (F<Config_heavy.pl>),
L<AnyEvent> needs at least one event loop backend that we have to
specify manually (here L<AnyEvent::Impl::Perl>), and the F<URI> module
(required by L<AnyEvent::HTTPD>) implements various URI schemes as extra
modules - since L<AnyEvent::HTTPD> only needs C<http> URIs, we only need
to include that module. I found out about these dependencies by carefully
watching any error messages about missing modules...

Instead of building a new perl binary, you can also build a standalone
application:

   # build the app
   staticperl mkapp app --boot eg/httpd \
                    -MAnyEvent::Impl::Perl -MAnyEvent::HTTPD -MURI::http

   # run it
   ./app

=head3 OPTION PROCESSING

All options can be given as arguments on the command line (typically
using long (e.g. C<--verbose>) or short option (e.g. C<-v>) style). Since
specifying a lot of modules can make the command line very cumbersome,
you can put all long options into a "bundle specification file" (with or
without C<--> prefix) and specify this bundle file instead.

For example, the command given earlier could also look like this:

   staticperl mkperl httpd.bundle

And all options could be in F<httpd.bundle>:
   
   use "Config_heavy.pl"
   use AnyEvent::Impl::Perl
   use AnyEvent::HTTPD
   use URI::http
   add eg/httpd httpd.pm

All options that specify modules or files to be added are processed in the
order given on the command line (that affects the C<--use> and C<--eval>
options at the moment).

=head3 MKBUNDLE OPTIONS

=over 4

=item --verbose | -v

Increases the verbosity level by one (the default is C<1>).

=item --quiet | -q

Decreases the verbosity level by one.

=item --strip none|pod|ppi

Specify the stripping method applied to reduce the file of the perl
sources included.

The default is C<pod>, which uses the L<Pod::Strip> module to remove all
pod documentation, which is very fast and reduces file size a lot.

The C<ppi> method uses L<PPI> to parse and condense the perl sources. This
saves a lot more than just L<Pod::Strip>, and is generally safer, but
is also a lot slower, so is best used for production builds. Note that
this method doesn't optimise for raw file size, but for best compression
(that means that the uncompressed file size is a bit larger, but the files
compress better, e.g. with F<upx>).

Last not least, if you need accurate line numbers in error messages,
or in the unlikely case where C<pod> is too slow, or some module gets
mistreated, you can specify C<none> to not mangle included perl sources in
any way.

=item --perl

After writing out the bundle files, try to link a new perl interpreter. It
will be called F<perl> and will be left in the current working
directory. The bundle files will be removed.

This switch is automatically used when F<staticperl> is invoked with the
C<mkperl> command (instead of C<mkbundle>):

   # build a new ./perl with only common::sense in it - very small :)
   staticperl mkperl -Mcommon::sense

=item --app name

After writing out the bundle files, try to link a new standalone
program. It will be called C<name>, and the bundle files get removed after
linking it.

The difference to the (mutually exclusive) C<--perl> option is that the
binary created by this option will not try to act as a perl interpreter -
instead it will simply initialise the perl interpreter, clean it up and
exit.

This switch is automatically used when F<staticperl> is invoked with the
C<mkapp> command (instead of C<mkbundle>):

To let it do something useful you I<must> add some boot code, e.g. with
the C<--boot> option.

Example: create a standalone perl binary that will execute F<appfile> when
it is started.

   staticperl mkbundle --app myexe --boot appfile

=item --use module | -Mmodule

Include the named module and all direct dependencies. This is done by
C<require>'ing the module in a subprocess and tracing which other modules
and files it actually loads. If the module uses L<AutoLoader>, then all
splitfiles will be included as well.

Example: include AnyEvent and AnyEvent::Impl::Perl.

   staticperl mkbundle --use AnyEvent --use AnyEvent::Impl::Perl

Sometimes you want to load old-style "perl libraries" (F<.pl> files), or
maybe other weirdly named files. To do that, you need to quote the name in
single or double quotes. When given on the command line, you probably need
to quote once more to avoid your shell interpreting it. Common cases that
need this are F<Config_heavy.pl> and F<utf8_heavy.pl>.

Example: include the required files for F<perl -V> to work in all its
glory (F<Config.pm> is included automatically by this).

   # bourne shell
   staticperl mkbundle --use '"Config_heavy.pl"'

   # bundle specification file
   use "Config_heavy.pl"

The C<-Mmodule> syntax is included as an alias that might be easier to
remember than C<use>. Or maybe it confuses people. Time will tell. Or
maybe not. Argh.

=item --eval "perl code" | -e "perl code"

Sometimes it is easier (or necessary) to specify dependencies using perl
code, or maybe one of the modules you use need a special use statement. In
that case, you can use C<eval> to execute some perl snippet or set some
variables or whatever you need. All files C<require>'d or C<use>'d in the
script are included in the final bundle.

Keep in mind that F<mkbundle> will only C<require> the modules named
by the C<--use> option, so do not expect the symbols from modules you
C<--use>'d earlier on the command line to be available.

Example: force L<AnyEvent> to detect a backend and therefore include it
in the final bundle.

   staticperl mkbundle --eval 'use AnyEvent; AnyEvent::detect'

   # or like this
   staticperl mkbundle -MAnyEvent --eval 'use AnyEvent; AnyEvent::detect'

Example: use a separate "bootstrap" script that C<use>'s lots of modules
and include this in the final bundle, to be executed automatically.

   staticperl mkbundle --eval 'do "bootstrap"' --boot bootstrap

=item --boot filename

Include the given file in the bundle and arrange for it to be executed
(using a C<require>) before anything else when the new perl is
initialised. This can be used to modify C<@INC> or anything else before
the perl interpreter executes scripts given on the command line (or via
C<-e>). This works even in an embedded interpreter.

=item --add "file" | --add "file alias"

Adds the given (perl) file into the bundle (and optionally call it
"alias"). This is useful to include any custom files into the bundle.

Example: embed the file F<httpd> as F<httpd.pm> when creating the bundle.

   staticperl mkperl --add "httpd httpd.pm"

It is also a great way to add any custom modules:

   # specification file
   add file1 myfiles/file1
   add file2 myfiles/file2
   add file3 myfiles/file3

=item --binadd "file" | --add "file alias"

Just like C<--add>, except that it treats the file as binary and adds it
without any processing.

You should probably add a C</> prefix to avoid clashing with embedded
perl files (whose paths do not start with C</>), and/or use a special
directory, such as C</res/name>.

You can later get a copy of these files by calling C<staticperl::find
"alias">.

=item --static

When C<--perl> is also given, link statically instead of dynamically. The
default is to link the new perl interpreter fully dynamic (that means all
perl modules are linked statically, but all external libraries are still
referenced dynamically).

Keep in mind that Solaris doesn't support static linking at all, and
systems based on GNU libc don't really support it in a usable fashion
either. Try uClibc if you want to create fully statically linked
executables, or try the C<--staticlibs> option to link only some libraries
statically.

=item any other argument

Any other argument is interpreted as a bundle specification file, which
supports most long options (without extra quoting), one option per line.

=back

=head2 F<STATCPERL> CONFIGURATION AND HOOKS

During (each) startup, F<staticperl> tries to source the following shell
files in order:

   /etc/staticperlrc
   ~/.staticperlrc
   $STATICPERL/rc

They can be used to override shell variables, or define functions to be
called at specific phases.

Note that the last file is erased during F<staticperl distclean>, so
generally should not be used.

=head3 CONFIGURATION VARIABLES

=head4 Variables you I<should> override

=over 4

=item C<EMAIL>

The e-mail address of the person who built this binary. Has no good
default, so should be specified by you.

=item C<CPAN>

The URL of the CPAN mirror to use (e.g. L<http://mirror.netcologne.de/cpan/>).

=item C<EXTRA_MODULES>

Additional modules installed during F<staticperl install>. Here you can
set which modules you want have to installed from CPAN.

Example: I really really need EV, AnyEvent, Coro and AnyEvent::AIO.

   EXTRA_MODULES="EV AnyEvent Coro AnyEvent::AIO"

Note that you can also use a C<postinstall> hook to achieve this, and
more.

=back

=head4 Variables you might I<want> to override

=over 4

=item C<STATICPERL>

The directory where staticperl stores all its files
(default: F<~/.staticperl>).

=item C<PERL_MM_USE_DEFAULT>, C<EV_EXTRA_DEFS>, ...

Usually set to C<1> to make modules "less inquisitive" during their
installation, you can set any environment variable you want - some modules
(such as L<Coro> or L<EV>) use environment variables for further tweaking.

=item C<PERL_VERSION>

The perl version to install - default is currently C<5.12.2>, but C<5.8.9>
is also a good choice (5.8.9 is much smaller than 5.12.2, while 5.10.1 is
about as big as 5.12.2).

=item C<PERL_PREFIX>

The prefix where perl gets installed (default: F<$STATICPERL/perl>),
i.e. where the F<bin> and F<lib> subdirectories will end up.

=item C<PERL_CONFIGURE>

Additional Configure options - these are simply passed to the perl
Configure script. For example, if you wanted to enable dynamic loading,
you could pass C<-Dusedl>. To enable ithreads (Why would you want that
insanity? Don't! Use L<forks> instead!) you would pass C<-Duseithreads>
and so on.

More commonly, you would either activate 64 bit integer support
(C<-Duse64bitint>), or disable large files support (-Uuselargefiles), to
reduce filesize further.

=item C<PERL_CPPFLAGS>, C<PERL_OPTIMIZE>, C<PERL_LDFLAGS>, C<PERL_LIBS>

These flags are passed to perl's F<Configure> script, and are generally
optimised for small size (at the cost of performance). Since they also
contain subtle workarounds around various build issues, changing these
usually requires understanding their default values - best look at the top
of the F<staticperl> script for more info on these.

=back

=head4 Variables you probably I<do not want> to override

=over 4

=item C<MKBUNDLE>

Where F<staticperl> writes the C<mkbundle> command to
(default: F<$STATICPERL/mkbundle>).

=item C<STATICPERL_MODULES>

Additional modules needed by C<mkbundle> - should therefore not be changed
unless you know what you are doing.

=back

=head3 OVERRIDABLE HOOKS

In addition to environment variables, it is possible to provide some
shell functions that are called at specific times. To provide your own
commands, just define the corresponding function.

Example: install extra modules from CPAN and from some directories
at F<staticperl install> time.

   postinstall() {
      rm -rf lib/threads* # weg mit Schaden
      instcpan IO::AIO EV
      instsrc ~/src/AnyEvent
      instsrc ~/src/XML-Sablotron-1.0100001
      instcpan Anyevent::AIO AnyEvent::HTTPD
   }

=over 4

=item preconfigure

Called just before running F<./Configur> in the perl source
directory. Current working directory is the perl source directory.

This can be used to set any C<PERL_xxx> variables, which might be costly
to compute.

=item postconfigure

Called after configuring, but before building perl. Current working
directory is the perl source directory.

Could be used to tailor/patch config.sh (followed by F<sh Configure -S>)
or do any other modifications.

=item postbuild

Called after building, but before installing perl. Current working
directory is the perl source directory.

I have no clue what this could be used for - tell me.

=item postinstall

Called after perl and any extra modules have been installed in C<$PREFIX>,
but before setting the "installation O.K." flag.

The current working directory is C<$PREFIX>, but maybe you should not rely
on that.

This hook is most useful to customise the installation, by deleting files,
or installing extra modules using the C<instcpan> or C<instsrc> functions.

The script must return with a zero exit status, or the installation will
fail.

=back

=head1 ANATOMY OF A BUNDLE

When not building a new perl binary, C<mkbundle> will leave a number of
files in the current working directory, which can be used to embed a perl
interpreter in your program.

Intimate knowledge of L<perlembed> and preferably some experience with
embedding perl is highly recommended.

C<mkperl> (or the C<--perl> option) basically does this to link the new
interpreter (it also adds a main program to F<bundle.>):

   $Config{cc} $(cat bundle.ccopts) -o perl bundle.c $(cat bundle.ldopts)

=over 4

=item bundle.h

A header file that contains the prototypes of the few symbols "exported"
by bundle.c, and also exposes the perl headers to the application.

=over 4

=item staticperl_init ()

Initialises the perl interpreter. You can use the normal perl functions
after calling this function, for example, to define extra functions or
to load a .pm file that contains some initialisation code, or the main
program function:

   XS (xsfunction)
   {
     dXSARGS;

     // now we have items, ST(i) etc.
   }

   static void
   run_myapp(void)
   {
      staticperl_init ();
      newXSproto ("myapp::xsfunction", xsfunction, __FILE__, "$$;$");
      eval_pv ("require myapp::main", 1); // executes "myapp/main.pm"
   }

=item staticperl_xs_init (pTHX)

Sometimes you need direct control over C<perl_parse> and C<perl_run>, in
which case you do not want to use C<staticperl_init> but call them on your
own.

Then you need this function - either pass it directly as the C<xs_init>
function to C<perl_parse>, or call it from your own C<xs_init> function.

=item staticperl_cleanup ()

In the unlikely case that you want to destroy the perl interpreter, here
is the corresponding function.

=item PerlInterpreter *staticperl

The perl interpreter pointer used by staticperl. Not normally so useful,
but there it is.

=back

=item bundle.ccopts

Contains the compiler options required to compile at least F<bundle.c> and
any file that includes F<bundle.h> - you should probably use it in your
C<CFLAGS>.

=item bundle.ldopts

The linker options needed to link the final program.

=back

=head1 RUNTIME FUNCTIONALITY

Binaries created with C<mkbundle>/C<mkperl> contain extra functions, which
are required to access the bundled perl sources, but might be useful for
other purposes.

In addition, for the embedded loading of perl files to work, F<staticperl>
overrides the C<@INC> array.

=over 4

=item $file = staticperl::find $path

Returns the data associated with the given C<$path>
(e.g. C<Digest/MD5.pm>, C<auto/POSIX/autosplit.ix>), which is basically
the UNIX path relative to the perl library directory.

Returns C<undef> if the file isn't embedded.

=item @paths = staticperl::list

Returns the list of all paths embedded in this binary.

=back

=head1 FULLY STATIC BINARIES - BUILDROOT

To make truly static (Linux-) libraries, you might want to have a look at
buildroot (L<http://buildroot.uclibc.org/>).

Buildroot is primarily meant to set up a cross-compile environment (which
is not so useful as perl doesn't quite like cross compiles), but it can also compile
a chroot environment where you can use F<staticperl>.

To do so, download buildroot, and enable "Build options => development
files in target filesystem" and optionally "Build options => gcc
optimization level (optimize for size)". At the time of writing, I had
good experiences with GCC 4.4.x but not GCC 4.5.

To minimise code size, I used C<-pipe -ffunction-sections -fdata-sections
-finline-limit=8 -fno-builtin-strlen -mtune=i386>. The C<-mtune=i386>
doesn't decrease codesize much, but it makes the file much more
compressible.

If you don't need Coro or threads, you can go with "linuxthreads.old" (or
no thread support). For Coro, it is highly recommended to switch to a
uClibc newer than 0.9.31 (at the time of this writing, I used the 20101201
snapshot) and enable NPTL, otherwise Coro needs to be configured with the
ultra-slow pthreads backend to work around linuxthreads bugs (it also uses
twice the address space needed for stacks).

If you use C<linuxthreads.old>, then you should also be aware that
uClibc shares C<errno> between all threads when statically linking. See
L<http://lists.uclibc.org/pipermail/uclibc/2010-June/044157.html> for a
workaround (And L<https://bugs.uclibc.org/2089> for discussion).

C<ccache> support is also recommended, especially if you want
to play around with buildroot options. Enabling the C<miniperl>
package will probably enable all options required for a successful
perl build. F<staticperl> itself additionally needs either C<wget>
(recommended, for CPAN) or C<curl>.

As for shells, busybox should provide all that is needed, but the default
busybox configuration doesn't include F<comm> which is needed by perl -
either make a custom busybox config, or compile coreutils.

For the latter route, you might find that bash has some bugs that keep
it from working properly in a chroot - either use dash (and link it to
F</bin/sh> inside the chroot) or link busybox to F</bin/sh>, using it's
built-in ash shell.

Finally, you need F</dev/null> inside the chroot for many scripts to work
- F<cp /dev/null output/target/dev> or bind-mounting your F</dev> will
both provide this.

After you have compiled and set up your buildroot target, you can copy
F<staticperl> from the C<App::Staticperl> distribution or from your
perl f<bin> directory (if you installed it) into the F<output/target>
filesystem, chroot inside and run it.

=head1 AUTHOR

 Marc Lehmann <schmorp@schmorp.de>
 http://software.schmorp.de/pkg/staticperl.html

