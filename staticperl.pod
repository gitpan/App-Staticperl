=head1 NAME

staticperl - perl, libc, 100 modules, all in one 500kb file

=head1 SYNOPSIS

   staticperl help      # print the embedded documentation
   staticperl fetch     # fetch and unpack perl sources
   staticperl configure # fetch and then configure perl
   staticperl build     # configure and then build perl
   staticperl install   # build and then install perl
   staticperl clean     # clean most intermediate files (restart at configure)
   staticperl distclean # delete everything installed by this script
   staticperl perl ...  # invoke the perlinterpreter
   staticperl cpan      # invoke CPAN shell
   staticperl instmod path...        # install unpacked modules
   staticperl instcpan modulename... # install modules from CPAN
   staticperl mkbundle <bundle-args...> # see documentation
   staticperl mkperl <bundle-args...>   # see documentation
   staticperl mkapp appname <bundle-args...> # see documentation

Typical Examples:

   staticperl install   # fetch, configure, build and install perl
   staticperl cpan      # run interactive cpan shell
   staticperl mkperl -MConfig_heavy.pl # build a perl that supports -V
   staticperl mkperl -MAnyEvent::Impl::Perl -MAnyEvent::HTTPD -MURI -MURI::http
                        # build a perl with the above modules linked in
   staticperl mkapp myapp --boot mainprog mymodules
                        # build a binary "myapp" from mainprog and mymodules

=head1 DESCRIPTION

This script helps you to create single-file perl interpreters
or applications, or embedding a perl interpreter in your
applications. Single-file means that it is fully self-contained - no
separate shared objects, no autoload fragments, no .pm or .pl files are
needed. And when linking statically, you can create (or embed) a single
file that contains perl interpreter, libc, all the modules you need, all
the libraries you need and of course your actual program.

With F<uClibc> and F<upx> on x86, you can create a single 500kb binary
that contains perl and 100 modules such as POSIX, AnyEvent, EV, IO::AIO,
Coro and so on. Or any other choice of modules (and some other size :).

To see how this turns out, you can try out smallperl and bigperl, two
pre-built static and compressed perl binaries with many and even more
modules: just follow the links at L<http://staticperl.schmorp.de/>.

The created files do not need write access to the file system (like PAR
does). In fact, since this script is in many ways similar to PAR::Packer,
here are the differences:

=over 4

=item * The generated executables are much smaller than PAR created ones.

Shared objects and the perl binary contain a lot of extra info, while
the static nature of F<staticperl> allows the linker to remove all
functionality and meta-info not required by the final executable. Even
extensions statically compiled into perl at build time will only be
present in the final executable when needed.

In addition, F<staticperl> can strip perl sources much more effectively
than PAR.

=item * The generated executables start much faster.

There is no need to unpack files, or even to parse Zip archives (which is
slow and memory-consuming business).

=item * The generated executables don't need a writable filesystem.

F<staticperl> loads all required files directly from memory. There is no
need to unpack files into a temporary directory.

=item * More control over included files, more burden.

PAR tries to be maintenance and hassle-free - it tries to include more
files than necessary to make sure everything works out of the box. It
mostly succeeds at this, but he extra files (such as the unicode database)
can take substantial amounts of memory and file size.

With F<staticperl>, the burden is mostly with the developer - only direct
compile-time dependencies and L<AutoLoader> are handled automatically.
This means the modules to include often need to be tweaked manually.

All this does not preclude more permissive modes to be implemented in
the future, but right now, you have to resolve state hidden dependencies
manually.

=item * PAR works out of the box, F<staticperl> does not.

Maintaining your own custom perl build can be a pain in the ass, and while
F<staticperl> tries to make this easy, it still requires a custom perl
build and possibly fiddling with some modules. PAR is likely to produce
results faster.

Ok, PAR never has worked for me out of the box, and for some people,
F<staticperl> does work out of the box, as they don't count "fiddling with
module use lists" against it, but nevertheless, F<staticperl> is certainly
a bit more difficult to use.

=back

=head1 HOW DOES IT WORK?

Simple: F<staticperl> downloads, compile and installs a perl version of
your choice in F<~/.staticperl>. You can add extra modules either by
letting F<staticperl> install them for you automatically, or by using CPAN
and doing it interactively. This usually takes 5-10 minutes, depending on
the speed of your computer and your internet connection.

It is possible to do program development at this stage, too.

Afterwards, you create a list of files and modules you want to include,
and then either build a new perl binary (that acts just like a normal perl
except everything is compiled in), or you create bundle files (basically C
sources you can use to embed all files into your project).

This step is very fast (a few seconds if PPI is not used for stripping, or
the stripped files are in the cache), and can be tweaked and repeated as
often as necessary.

=head1 THE F<STATICPERL> SCRIPT

This module installs a script called F<staticperl> into your perl
binary directory. The script is fully self-contained, and can be
used without perl (for example, in an uClibc chroot environment). In
fact, it can be extracted from the C<App::Staticperl> distribution
tarball as F<bin/staticperl>, without any installation. The
newest (possibly alpha) version can also be downloaded from
L<http://staticperl.schmorp.de/staticperl>.

F<staticperl> interprets the first argument as a command to execute,
optionally followed by any parameters.

There are two command categories: the "phase 1" commands which deal with
installing perl and perl modules, and the "phase 2" commands, which deal
with creating binaries and bundle files.

=head2 PHASE 1 COMMANDS: INSTALLING PERL

The most important command is F<install>, which does basically
everything. The default is to download and install perl 5.12.3 and a few
modules required by F<staticperl> itself, but all this can (and should) be
changed - see L<CONFIGURATION>, below.

The command

   staticperl install

is normally all you need: It installs the perl interpreter in
F<~/.staticperl/perl>. It downloads, configures, builds and installs the
perl interpreter if required.

Most of the following F<staticperl> subcommands simply run one or more
steps of this sequence.

If it fails, then most commonly because the compiler options I selected
are not supported by your compiler - either edit the F<staticperl> script
yourself or create F<~/.staticperl> shell script where your set working
C<PERL_CCFLAGS> etc. variables.

To force recompilation or reinstallation, you need to run F<staticperl
distclean> first.

=over 4

=item F<staticperl version>

Prints some info about the version of the F<staticperl> script you are using.

=item F<staticperl fetch>

Runs only the download and unpack phase, unless this has already happened.

=item F<staticperl configure>

Configures the unpacked perl sources, potentially after downloading them first.

=item F<staticperl build>

Builds the configured perl sources, potentially after automatically
configuring them.

=item F<staticperl install>

Wipes the perl installation directory (usually F<~/.staticperl/perl>) and
installs the perl distribution, potentially after building it first.

=item F<staticperl perl> [args...]

Invokes the compiled perl interpreter with the given args. Basically the
same as starting perl directly (usually via F<~/.staticperl/bin/perl>),
but beats typing the path sometimes.

Example: check that the Gtk2 module is installed and loadable.

   staticperl perl -MGtk2 -e0

=item F<staticperl cpan> [args...]

Starts an interactive CPAN shell that you can use to install further
modules. Installs the perl first if necessary, but apart from that,
no magic is involved: you could just as well run it manually via
F<~/.staticperl/perl/bin/cpan>.

Any additional arguments are simply passed to the F<cpan> command.

=item F<staticperl instcpan> module...

Tries to install all the modules given and their dependencies, using CPAN.

Example:

   staticperl instcpan EV AnyEvent::HTTPD Coro

=item F<staticperl instsrc> directory...

In the unlikely case that you have unpacked perl modules around and want
to install from these instead of from CPAN, you can do this using this
command by specifying all the directories with modules in them that you
want to have built.

=item F<staticperl clean>

Deletes the perl source directory (and potentially cleans up other
intermediate files). This can be used to clean up files only needed for
building perl, without removing the installed perl interpreter.

At the moment, it doesn't delete downloaded tarballs.

The exact semantics of this command will probably change.

=item F<staticperl distclean>

This wipes your complete F<~/.staticperl> directory. Be careful with this,
it nukes your perl download, perl sources, perl distribution and any
installed modules. It is useful if you wish to start over "from scratch"
or when you want to uninstall F<staticperl>.

=back

=head2 PHASE 2 COMMANDS: BUILDING PERL BUNDLES

Building (linking) a new F<perl> binary is handled by a separate
script. To make it easy to use F<staticperl> from a F<chroot>, the script
is embedded into F<staticperl>, which will write it out and call for you
with any arguments you pass:

   staticperl mkbundle mkbundle-args...

In the oh so unlikely case of something not working here, you
can run the script manually as well (by default it is written to
F<~/.staticperl/mkbundle>).

F<mkbundle> is a more conventional command and expect the argument
syntax commonly used on UNIX clones. For example, this command builds
a new F<perl> binary and includes F<Config.pm> (for F<perl -V>),
F<AnyEvent::HTTPD>, F<URI> and a custom F<httpd> script (from F<eg/httpd>
in this distribution):

   # first make sure we have perl and the required modules
   staticperl instcpan AnyEvent::HTTPD

   # now build the perl
   staticperl mkperl -MConfig_heavy.pl -MAnyEvent::Impl::Perl \
                     -MAnyEvent::HTTPD -MURI::http \
                     --add 'eg/httpd httpd.pm'

   # finally, invoke it
   ./perl -Mhttpd

As you can see, things are not quite as trivial: the L<Config> module has
a hidden dependency which is not even a perl module (F<Config_heavy.pl>),
L<AnyEvent> needs at least one event loop backend that we have to
specify manually (here L<AnyEvent::Impl::Perl>), and the F<URI> module
(required by L<AnyEvent::HTTPD>) implements various URI schemes as extra
modules - since L<AnyEvent::HTTPD> only needs C<http> URIs, we only need
to include that module. I found out about these dependencies by carefully
watching any error messages about missing modules...

Instead of building a new perl binary, you can also build a standalone
application:

   # build the app
   staticperl mkapp app --boot eg/httpd \
                    -MAnyEvent::Impl::Perl -MAnyEvent::HTTPD -MURI::http

   # run it
   ./app

Here are the three phase 2 commands:

=over 4

=item F<staticperl mkbundle> args...

The "default" bundle command - it interprets the given bundle options and
writes out F<bundle.h>, F<bundle.c>, F<bundle.ccopts> and F<bundle.ldopts>
files, useful for embedding.

=item F<staticperl mkperl> args...

Creates a bundle just like F<staticperl mkbundle> (in fact, it's the same
as invoking F<staticperl mkbundle --perl> args...), but then compiles and
links a new perl interpreter that embeds the created bundle, then deletes
all intermediate files.

=item F<staticperl mkapp> filename args...

Does the same as F<staticperl mkbundle> (in fact, it's the same as
invoking F<staticperl mkbundle --app> filename args...), but then compiles
and links a new standalone application that simply initialises the perl
interpreter.

The difference to F<staticperl mkperl> is that the standalone application
does not act like a perl interpreter would - in fact, by default it would
just do nothing and exit immediately, so you should specify some code to
be executed via the F<--boot> option.

=back

=head3 OPTION PROCESSING

All options can be given as arguments on the command line (typically
using long (e.g. C<--verbose>) or short option (e.g. C<-v>) style). Since
specifying a lot of options can make the command line very long and
unwieldy, you can put all long options into a "bundle specification file"
(one option per line, with or without C<--> prefix) and specify this
bundle file instead.

For example, the command given earlier to link a new F<perl> could also
look like this:

   staticperl mkperl httpd.bundle

With all options stored in the F<httpd.bundle> file (one option per line,
everything after the option is an argument):

   use "Config_heavy.pl"
   use AnyEvent::Impl::Perl
   use AnyEvent::HTTPD
   use URI::http
   add eg/httpd httpd.pm

All options that specify modules or files to be added are processed in the
order given on the command line.

=head3 BUNDLE CREATION WORKFLOW / STATICPELR MKBUNDLE OPTIONS

F<staticperl mkbundle> works by first assembling a list of candidate
files and modules to include, then filtering them by include/exclude
patterns. The remaining modules (together with their direct dependencies,
such as link libraries and L<AutoLoader> files) are then converted into
bundle files suitable for embedding. F<staticperl mkbundle> can then
optionally build a new perl interpreter or a standalone application.

=over 4

=item Step 0: Generic argument processing.

The following options influence F<staticperl mkbundle> itself.

=over 4

=item C<--verbose> | C<-v>

Increases the verbosity level by one (the default is C<1>).

=item C<--quiet> | C<-q>

Decreases the verbosity level by one.

=item any other argument

Any other argument is interpreted as a bundle specification file, which
supports all options (without extra quoting), one option per line, in the
format C<option> or C<option argument>. They will effectively be expanded
and processed as if they were directly written on the command line, in
place of the file name.

=back

=item Step 1: gather candidate files and modules

In this step, modules, perl libraries (F<.pl> files) and other files are
selected for inclusion in the bundle. The relevant options are executed
in order (this makes a difference mostly for C<--eval>, which can rely on
earlier C<--use> options to have been executed).

=over 4

=item C<--use> F<module> | C<-M>F<module>

Include the named module or perl library and trace direct
dependencies. This is done by loading the module in a subprocess and
tracing which other modules and files it actually loads.

Example: include AnyEvent and AnyEvent::Impl::Perl.

   staticperl mkbundle --use AnyEvent --use AnyEvent::Impl::Perl

Sometimes you want to load old-style "perl libraries" (F<.pl> files), or
maybe other weirdly named files. To support this, the C<--use> option
actually tries to do what you mean, depending on the string you specify:

=over 4

=item a possibly valid module name, e.g. F<common::sense>, F<Carp>,
F<Coro::Mysql>.

If the string contains no quotes, no F</> and no F<.>, then C<--use>
assumes that it is a normal module name. It will create a new package and
evaluate a C<use module> in it, i.e. it will load the package and do a
default import.

The import step is done because many modules trigger more dependencies
when something is imported than without.

=item anything that contains F</> or F<.> characters,
e.g. F<utf8_heavy.pl>, F<Module/private/data.pl>.

The string will be quoted and passed to require, as if you used C<require
$module>. Nothing will be imported.

=item "path" or 'path', e.g. C<"utf8_heavy.pl">.

If you enclose the name into single or double quotes, then the quotes will
be removed and the resulting string will be passed to require. This syntax
is form compatibility with older versions of staticperl and should not be
used anymore.

=back

Example: C<use> AnyEvent::Socket, once using C<use> (importing the
symbols), and once via C<require>, not importing any symbols. The first
form is preferred as many modules load some extra dependencies when asked
to export symbols.

   staticperl mkbundle -MAnyEvent::Socket     # use + import
   staticperl mkbundle -MAnyEvent/Socket.pm   # require only

Example: include the required files for F<perl -V> to work in all its
glory (F<Config.pm> is included automatically by the dependency tracker).

   # shell command
   staticperl mkbundle -MConfig_heavy.pl

   # bundle specification file
   use Config_heavy.pl

The C<-M>module syntax is included as a convenience that might be easier
to remember than C<--use> - it's the same switch as perl itself uses
to load modules. Or maybe it confuses people. Time will tell. Or maybe
not. Sigh.

=item C<--eval> "perl code" | C<-e> "perl code"

Sometimes it is easier (or necessary) to specify dependencies using perl
code, or maybe one of the modules you use need a special use statement. In
that case, you can use C<--eval> to execute some perl snippet or set some
variables or whatever you need. All files C<require>'d or C<use>'d while
executing the snippet are included in the final bundle.

Keep in mind that F<mkbundle> will not import any symbols from the modules
named by the C<--use> option, so do not expect the symbols from modules
you C<--use>'d earlier on the command line to be available.

Example: force L<AnyEvent> to detect a backend and therefore include it
in the final bundle.

   staticperl mkbundle --eval 'use AnyEvent; AnyEvent::detect'

   # or like this
   staticperl mkbundle -MAnyEvent --eval 'AnyEvent::detect'

Example: use a separate "bootstrap" script that C<use>'s lots of modules
and also include this in the final bundle, to be executed automatically
when the interpreter is initialised.

   staticperl mkbundle --eval 'do "bootstrap"' --boot bootstrap

=item C<--boot> F<filename>

Include the given file in the bundle and arrange for it to be
executed (using C<require>) before the main program when the new perl
is initialised. This can be used to modify C<@INC> or do similar
modifications before the perl interpreter executes scripts given on the
command line (or via C<-e>). This works even in an embedded interpreter -
the file will be executed during interpreter initialisation in that case.

=item C<--incglob> pattern

This goes through all standard library directories and tries to match any
F<.pm> and F<.pl> files against the extended glob pattern (see below). If
a file matches, it is added. The pattern is matched against the full path
of the file (sans the library directory prefix), e.g. F<Sys/Syslog.pm>.

This is very useful to include "everything":

   --incglob '*'

It is also useful for including perl libraries, or trees of those, such as
the unicode database files needed by some perl built-ins, the regex engine
and other modules.

   --incglob '/unicore/**.pl'

=item C<--add> F<file> | C<--add> "F<file> alias"

Adds the given (perl) file into the bundle (and optionally call it
"alias"). The F<file> is either an absolute path or a path relative to the
current directory. If an alias is specified, then this is the name it will
use for C<@INC> searches, otherwise the path F<file> will be used as the
internal name.

This switch is used to include extra files into the bundle.

Example: embed the file F<httpd> in the current directory as F<httpd.pm>
when creating the bundle.

   staticperl mkperl --add "httpd httpd.pm"

   # can be accessed via "use httpd"

Example: add a file F<initcode> from the current directory.

   staticperl mkperl --add 'initcode &initcode'

   # can be accessed via "do '&initcode'"

Example: add local files as extra modules in the bundle.

   # specification file
   add file1 myfiles/file1.pm
   add file2 myfiles/file2.pm
   add file3 myfiles/file3.pl

   # then later, in perl, use
   use myfiles::file1;
   require myfiles::file2;
   my $res = do "myfiles/file3.pl";

=item C<--binadd> F<file> | C<--add> "F<file> alias"

Just like C<--add>, except that it treats the file as binary and adds it
without any postprocessing (perl files might get stripped to reduce their
size).

If you specify an alias you should probably add a C<&> prefix to avoid
clashing with embedded perl files (whose paths never start with C<&>),
and/or use a special directory prefix, such as C<&res/name>.

You can later get a copy of these files by calling C<staticperl::find
"alias">.

An alternative way to embed binary files is to convert them to perl and
use C<do> to get the contents - this method is a bit cumbersome, but works
both inside and outside of a staticperl bundle:

   # a "binary" file, call it "bindata.pl"
   <<'SOME_MARKER'
   binary data NOT containing SOME_MARKER
   SOME_MARKER

   # load the binary
   chomp (my $data = do "bindata.pl");

=back

=item Step 2: filter all files using C<--include> and C<--exclude> options.

After all candidate files and modules are added, they are I<filtered>
by a combination of C<--include> and C<--exclude> patterns (there is an
implicit C<--include *> at the end, so if no filters are specified, all
files are included).

All that this step does is potentially reduce the number of files that are
to be included - no new files are added during this step.

=over 4

=item C<--include> pattern | C<-i> pattern | C<--exclude> pattern | C<-x> pattern

These specify an include or exclude pattern to be applied to the candidate
file list. An include makes sure that the given files will be part of the
resulting file set, an exclude will exclude remaining files. The patterns
are "extended glob patterns" (see below).

The patterns are applied "in order" - files included via earlier
C<--include> specifications cannot be removed by any following
C<--exclude>, and likewise, and file excluded by an earlier C<--exclude>
cannot be added by any following C<--include>.

For example, to include everything except C<Devel> modules, but still
include F<Devel::PPPort>, you could use this:

   --incglob '*' -i '/Devel/PPPort.pm' -x '/Devel/**'

=back

=item Step 3: add any extra or "hidden" dependencies.

F<staticperl> currently knows about three extra types of depdendencies
that are added automatically. Only one (F<.packlist> files) is currently
optional and can be influenced, the others are always included:

=over 4

=item C<--usepacklists>

Read F<.packlist> files for each distribution that happens to match a
module name you specified. Sounds weird, and it is, so expect semantics to
change somehow in the future.

The idea is that most CPAN distributions have a F<.pm> file that matches
the name of the distribution (which is rather reasonable after all).

If this switch is enabled, then if any of the F<.pm> files that have been
selected match an install distribution, then all F<.pm>, F<.pl>, F<.al>
and F<.ix> files installed by this distribution are also included.

For example, using this switch, when the L<URI> module is specified, then
all L<URI> submodules that have been installed via the CPAN distribution
are included as well, so you don't have to manually specify them.

=item L<AutoLoader> splitfiles

Some modules use L<AutoLoader> - less commonly (hopefully) used functions
are split into separate F<.al> files, and an index (F<.ix>) file contains
the prototypes.

Both F<.ix> and F<.al> files will be detected automatically and added to
the bundle.

=item link libraries (F<.a> files)

Modules using XS (or any other non-perl language extension compiled at
installation time) will have a static archive (typically F<.a>). These
will automatically be added to the linker options in F<bundle.ldopts>.

Should F<staticperl> find a dynamic link library (typically F<.so>) it
will warn about it - obviously this shouldn't happen unless you use
F<staticperl> on the wrong perl, or one (probably wrongly) configured to
use dynamic loading.

=item extra libraries (F<extralibs.ld>)

Some modules need linking against external libraries - these are found in
F<extralibs.ld> and added to F<bundle.ldopts>.

=back

=item Step 4: write bundle files and optionally link a program

At this point, the select files will be read, processed (stripped) and
finally the bundle files get written to disk, and F<staticperl mkbundle>
is normally finished. Optionally, it can go a step further and either link
a new F<perl> binary with all selected modules and files inside, or build
a standalone application.

Both the contents of the bundle files and any extra linking is controlled
by these options:

=over 4

=item C<--strip> C<none>|C<pod>|C<ppi>

Specify the stripping method applied to reduce the file of the perl
sources included.

The default is C<pod>, which uses the L<Pod::Strip> module to remove all
pod documentation, which is very fast and reduces file size a lot.

The C<ppi> method uses L<PPI> to parse and condense the perl sources. This
saves a lot more than just L<Pod::Strip>, and is generally safer,
but is also a lot slower (some files take almost a minute to strip -
F<staticperl> maintains a cache of stripped files to speed up subsequent
runs for this reason). Note that this method doesn't optimise for raw file
size, but for best compression (that means that the uncompressed file size
is a bit larger, but the files compress better, e.g. with F<upx>).

Last not least, if you need accurate line numbers in error messages,
or in the unlikely case where C<pod> is too slow, or some module gets
mistreated, you can specify C<none> to not mangle included perl sources in
any way.

=item C<--perl>

After writing out the bundle files, try to link a new perl interpreter. It
will be called F<perl> and will be left in the current working
directory. The bundle files will be removed.

This switch is automatically used when F<staticperl> is invoked with the
C<mkperl> command instead of C<mkbundle>.

Example: build a new F<./perl> binary with only L<common::sense> inside -
it will be even smaller than the standard perl interpreter as none of the
modules of the base distribution (such as L<Fcntl>) will be included.

   staticperl mkperl -Mcommon::sense

=item C<--app> F<name>

After writing out the bundle files, try to link a new standalone
program. It will be called C<name>, and the bundle files get removed after
linking it.

This switch is automatically used when F<staticperl> is invoked with the
C<mkapp> command instead of C<mkbundle>.

The difference to the (mutually exclusive) C<--perl> option is that the
binary created by this option will not try to act as a perl interpreter -
instead it will simply initialise the perl interpreter, clean it up and
exit.

This means that, by default, it will do nothing but burn a few CPU cycles
- for it to do something useful you I<must> add some boot code, e.g. with
the C<--boot> option.

Example: create a standalone perl binary called F<./myexe> that will
execute F<appfile> when it is started.

   staticperl mkbundle --app myexe --boot appfile

=item C<--ignore-env>

Generates extra code to unset some environment variables before
initialising/running perl. Perl supports a lot of environment variables
that might alter execution in ways that might be undesirablre for
standalone applications, and this option removes those known to cause
trouble.

Specifically, these are removed:

C<PERL_HASH_SEED_DEBUG> and C<PERL_DEBUG_MSTATS> can cause underaible
output, C<PERL5OPT>, C<PERL_DESTRUCT_LEVEL>, C<PERL_HASH_SEED> and
C<PERL_SIGNALS> can alter execution significantly, and C<PERL_UNICODE>,
C<PERLIO_DEBUG> and C<PERLIO> can affect input and output.

The variables C<PERL_LIB> and C<PERL5_LIB> are always ignored because the
startup code used by F<staticperl> overrides C<@INC> in all cases.

This option will not make your program more secure (unless you are
running with elevated privileges), but it will reduce the surprise effect
when a user has these environment variables set and doesn't expect your
standalone program to act like a perl interpreter.

=item C<--static>

Add C<-static> to F<bundle.ldopts>, which means a fully static (if
supported by the OS) executable will be created. This is not immensely
useful when just creating the bundle files, but is most useful when
linking a binary with the C<--perl> or C<--app> options.

The default is to link the new binary dynamically (that means all perl
modules are linked statically, but all external libraries are still
referenced dynamically).

Keep in mind that Solaris doesn't support static linking at all, and
systems based on GNU libc don't really support it in a very usable
fashion either. Try uClibc if you want to create fully statically linked
executables, or try the C<--staticlib> option to link only some libraries
statically.

=item C<--staticlib> libname

When not linking fully statically, this option allows you to link specific
libraries statically. What it does is simply replace all occurrences of
C<-llibname> with the GCC-specific C<-Wl,-Bstatic -llibname -Wl,-Bdynamic>
option.

This will have no effect unless the library is actually linked against,
specifically, C<--staticlib> will not link against the named library
unless it would be linked against anyway.

Example: link libcrypt statically into the final binary.

   staticperl mkperl -MIO::AIO --staticlib crypt

   # ldopts might now contain:
   # -lm -Wl,-Bstatic -lcrypt -Wl,-Bdynamic -lpthread

=back

=back

=head3 EXTENDED GLOB PATTERNS

Some options of F<staticperl mkbundle> expect an I<extended glob
pattern>. This is neither a normal shell glob nor a regex, but something
in between. The idea has been copied from rsync, and there are the current
matching rules:

=over 4

=item Patterns starting with F</> will be a anchored at the root of the library tree.

That is, F</unicore> will match the F<unicore> directory in C<@INC>, but
nothing inside, and neither any other file or directory called F<unicore>
anywhere else in the hierarchy.

=item Patterns not starting with F</> will be anchored at the end of the path.

That is, F<idna.pl> will match any file called F<idna.pl> anywhere in the
hierarchy, but not any directories of the same name.

=item A F<*> matches anything within a single path component.

That is, F</unicore/*.pl> would match all F<.pl> files directly inside
C</unicore>, not any deeper level F<.pl> files. Or in other words, F<*>
will not match slashes.

=item A F<**> matches anything.

That is, F</unicore/**.pl> would match all F<.pl> files under F</unicore>,
no matter how deeply nested they are inside subdirectories.

=item A F<?> matches a single character within a component.

That is, F</Encode/??.pm> matches F</Encode/JP.pm>, but not the
hypothetical F</Encode/J/.pm>, as F<?> does not match F</>.

=back

=head2 F<STATICPERL> CONFIGURATION AND HOOKS

During (each) startup, F<staticperl> tries to source some shell files to
allow you to fine-tune/override configuration settings.

In them you can override shell variables, or define shell functions
("hooks") to be called at specific phases during installation. For
example, you could define a C<postinstall> hook to install additional
modules from CPAN each time you start from scratch.

If the env variable C<$STATICPERLRC> is set, then F<staticperl> will try
to source the file named with it only. Otherwise, it tries the following
shell files in order:

   /etc/staticperlrc
   ~/.staticperlrc
   $STATICPERL/rc

Note that the last file is erased during F<staticperl distclean>, so
generally should not be used.

=head3 CONFIGURATION VARIABLES

=head4 Variables you I<should> override

=over 4

=item C<EMAIL>

The e-mail address of the person who built this binary. Has no good
default, so should be specified by you.

=item C<CPAN>

The URL of the CPAN mirror to use (e.g. L<http://mirror.netcologne.de/cpan/>).

=item C<EXTRA_MODULES>

Additional modules installed during F<staticperl install>. Here you can
set which modules you want have to installed from CPAN.

Example: I really really need EV, AnyEvent, Coro and AnyEvent::AIO.

   EXTRA_MODULES="EV AnyEvent Coro AnyEvent::AIO"

Note that you can also use a C<postinstall> hook to achieve this, and
more.

=back

=head4 Variables you might I<want> to override

=over 4

=item C<STATICPERL>

The directory where staticperl stores all its files
(default: F<~/.staticperl>).

=item C<PERL_MM_USE_DEFAULT>, C<EV_EXTRA_DEFS>, ...

Usually set to C<1> to make modules "less inquisitive" during their
installation, you can set any environment variable you want - some modules
(such as L<Coro> or L<EV>) use environment variables for further tweaking.

=item C<PERL_VERSION>

The perl version to install - default is currently C<5.12.3>, but C<5.8.9>
is also a good choice (5.8.9 is much smaller than 5.12.3, while 5.10.1 is
about as big as 5.12.3).

=item C<PERL_PREFIX>

The prefix where perl gets installed (default: F<$STATICPERL/perl>),
i.e. where the F<bin> and F<lib> subdirectories will end up.

=item C<PERL_CONFIGURE>

Additional Configure options - these are simply passed to the perl
Configure script. For example, if you wanted to enable dynamic loading,
you could pass C<-Dusedl>. To enable ithreads (Why would you want that
insanity? Don't! Use L<forks> instead!) you would pass C<-Duseithreads>
and so on.

More commonly, you would either activate 64 bit integer support
(C<-Duse64bitint>), or disable large files support (-Uuselargefiles), to
reduce filesize further.

=item C<PERL_CC>, C<PERL_CCFLAGS>, C<PERL_OPTIMIZE>, C<PERL_LDFLAGS>, C<PERL_LIBS>

These flags are passed to perl's F<Configure> script, and are generally
optimised for small size (at the cost of performance). Since they also
contain subtle workarounds around various build issues, changing these
usually requires understanding their default values - best look at
the top of the F<staticperl> script for more info on these, and use a
F<~/.staticperlrc> to override them.

Most of the variables override (or modify) the corresponding F<Configure>
variable, except C<PERL_CCFLAGS>, which gets appended.

You should have a look near the beginning of the F<staticperl> script -
staticperl tries to default C<PERL_OPTIMIZE> to some psace-saving options
suitable for newer gcc versions. For other compilers or older versions you
need to adjust these, for example, in your F<~/.staticperlrc>.

=back

=head4 Variables you probably I<do not want> to override

=over 4

=item C<MAKE>

The make command to use - default is C<make>.

=item C<MKBUNDLE>

Where F<staticperl> writes the C<mkbundle> command to
(default: F<$STATICPERL/mkbundle>).

=item C<STATICPERL_MODULES>

Additional modules needed by C<mkbundle> - should therefore not be changed
unless you know what you are doing.

=back

=head3 OVERRIDABLE HOOKS

In addition to environment variables, it is possible to provide some
shell functions that are called at specific times. To provide your own
commands, just define the corresponding function.

The actual order in which hooks are invoked during a full install
from scratch is C<preconfigure>, C<patchconfig>, C<postconfigure>,
C<postbuild>, C<postinstall>.

Example: install extra modules from CPAN and from some directories
at F<staticperl install> time.

   postinstall() {
      rm -rf lib/threads* # weg mit Schaden
      instcpan IO::AIO EV
      instsrc ~/src/AnyEvent
      instsrc ~/src/XML-Sablotron-1.0100001
      instcpan Anyevent::AIO AnyEvent::HTTPD
   }

=over 4

=item preconfigure

Called just before running F<./Configure> in the perl source
directory. Current working directory is the perl source directory.

This can be used to set any C<PERL_xxx> variables, which might be costly
to compute.

=item patchconfig

Called after running F<./Configure> in the perl source directory to create
F<./config.sh>, but before running F<./Configure -S> to actually apply the
config. Current working directory is the perl source directory.

Can be used to tailor/patch F<config.sh> or do any other modifications.

=item postconfigure

Called after configuring, but before building perl. Current working
directory is the perl source directory.

=item postbuild

Called after building, but before installing perl. Current working
directory is the perl source directory.

I have no clue what this could be used for - tell me.

=item postinstall

Called after perl and any extra modules have been installed in C<$PREFIX>,
but before setting the "installation O.K." flag.

The current working directory is C<$PREFIX>, but maybe you should not rely
on that.

This hook is most useful to customise the installation, by deleting files,
or installing extra modules using the C<instcpan> or C<instsrc> functions.

The script must return with a zero exit status, or the installation will
fail.

=back

=head1 ANATOMY OF A BUNDLE

When not building a new perl binary, C<mkbundle> will leave a number of
files in the current working directory, which can be used to embed a perl
interpreter in your program.

Intimate knowledge of L<perlembed> and preferably some experience with
embedding perl is highly recommended.

C<mkperl> (or the C<--perl> option) basically does this to link the new
interpreter (it also adds a main program to F<bundle.>):

   $Config{cc} $(cat bundle.ccopts) -o perl bundle.c $(cat bundle.ldopts)

=over 4

=item bundle.h

A header file that contains the prototypes of the few symbols "exported"
by bundle.c, and also exposes the perl headers to the application.

=over 4

=item staticperl_init (xs_init = 0)

Initialises the perl interpreter. You can use the normal perl functions
after calling this function, for example, to define extra functions or
to load a .pm file that contains some initialisation code, or the main
program function:

   XS (xsfunction)
   {
     dXSARGS;

     // now we have items, ST(i) etc.
   }

   static void
   run_myapp(void)
   {
      staticperl_init (0);
      newXSproto ("myapp::xsfunction", xsfunction, __FILE__, "$$;$");
      eval_pv ("require myapp::main", 1); // executes "myapp/main.pm"
   }

When your bootcode already wants to access some XS functions at
compiletime, then you need to supply an C<xs_init> function pointer that
is called as soon as perl is initialised enough to define XS functions,
but before the preamble code is executed:

   static void
   xs_init (pTHX)
   {
     newXSproto ("myapp::xsfunction", xsfunction, __FILE__, "$$;$");
   }

   static void
   run_myapp(void)
   {
      staticperl_init (xs_init);
   }

=item staticperl_cleanup ()

In the unlikely case that you want to destroy the perl interpreter, here
is the corresponding function.

=item staticperl_xs_init (pTHX)

Sometimes you need direct control over C<perl_parse> and C<perl_run>, in
which case you do not want to use C<staticperl_init> but call them on your
own.

Then you need this function - either pass it directly as the C<xs_init>
function to C<perl_parse>, or call it as one of the first things from your
own C<xs_init> function.

=item PerlInterpreter *staticperl

The perl interpreter pointer used by staticperl. Not normally so useful,
but there it is.

=back

=item bundle.ccopts

Contains the compiler options required to compile at least F<bundle.c> and
any file that includes F<bundle.h> - you should probably use it in your
C<CFLAGS>.

=item bundle.ldopts

The linker options needed to link the final program.

=back

=head1 RUNTIME FUNCTIONALITY

Binaries created with C<mkbundle>/C<mkperl> contain extra functions, which
are required to access the bundled perl sources, but might be useful for
other purposes.

In addition, for the embedded loading of perl files to work, F<staticperl>
overrides the C<@INC> array.

=over 4

=item $file = staticperl::find $path

Returns the data associated with the given C<$path>
(e.g. C<Digest/MD5.pm>, C<auto/POSIX/autosplit.ix>), which is basically
the UNIX path relative to the perl library directory.

Returns C<undef> if the file isn't embedded.

=item @paths = staticperl::list

Returns the list of all paths embedded in this binary.

=back

=head1 FULLY STATIC BINARIES - UCLIBC AND BUILDROOT

To make truly static (Linux-) libraries, you might want to have a look at
buildroot (L<http://buildroot.uclibc.org/>).

Buildroot is primarily meant to set up a cross-compile environment (which
is not so useful as perl doesn't quite like cross compiles), but it can also compile
a chroot environment where you can use F<staticperl>.

To do so, download buildroot, and enable "Build options => development
files in target filesystem" and optionally "Build options => gcc
optimization level (optimize for size)". At the time of writing, I had
good experiences with GCC 4.4.x but not GCC 4.5.

To minimise code size, I used C<-pipe -ffunction-sections -fdata-sections
-finline-limit=8 -fno-builtin-strlen -mtune=i386>. The C<-mtune=i386>
doesn't decrease codesize much, but it makes the file much more
compressible (and the execution a lot slower...).

If you don't need Coro or threads, you can go with "linuxthreads.old" (or
no thread support). For Coro, it is highly recommended to switch to a
uClibc newer than 0.9.31 (at the time of this writing, I used the 20101201
snapshot) and enable NPTL, otherwise Coro needs to be configured with the
ultra-slow pthreads backend to work around linuxthreads bugs (it also uses
twice the address space needed for stacks).

If you use C<linuxthreads.old>, then you should also be aware that
uClibc shares C<errno> between all threads when statically linking. See
L<http://lists.uclibc.org/pipermail/uclibc/2010-June/044157.html> for a
workaround (And L<https://bugs.uclibc.org/2089> for discussion).

C<ccache> support is also recommended, especially if you want
to play around with buildroot options. Enabling the C<miniperl>
package will probably enable all options required for a successful
perl build. F<staticperl> itself additionally needs either C<wget>
(recommended, for CPAN) or C<curl>.

As for shells, busybox should provide all that is needed, but the default
busybox configuration doesn't include F<comm> which is needed by perl -
either make a custom busybox config, or compile coreutils.

For the latter route, you might find that bash has some bugs that keep
it from working properly in a chroot - either use dash (and link it to
F</bin/sh> inside the chroot) or link busybox to F</bin/sh>, using it's
built-in ash shell.

Finally, you need F</dev/null> inside the chroot for many scripts to work
- F<cp /dev/null output/target/dev> or bind-mounting your F</dev> will
both provide this.

After you have compiled and set up your buildroot target, you can copy
F<staticperl> from the C<App::Staticperl> distribution or from your
perl f<bin> directory (if you installed it) into the F<output/target>
filesystem, chroot inside and run it.

=head1 RECIPES / SPECIFIC MODULES

This section contains some common(?) recipes and information about
problems with some common modules or perl constructs that require extra
files to be included.

=head2 MODULES

=over 4

=item utf8

Some functionality in the utf8 module, such as swash handling (used
for unicode character ranges in regexes) is implemented in the
C<"utf8_heavy.pl"> library:

   -Mutf8_heavy.pl

Many Unicode properties in turn are defined in separate modules,
such as C<"unicore/Heavy.pl"> and more specific data tables such as
C<"unicore/To/Digit.pl"> or C<"unicore/lib/Perl/Word.pl">. These tables
are big (7MB uncompressed, although F<staticperl> contains special
handling for those files), so including them on demand by your application
only might pay off.

To simply include the whole unicode database, use:

   --incglob '/unicore/**.pl'

=item AnyEvent

AnyEvent needs a backend implementation that it will load in a delayed
fashion. The L<AnyEvent::Impl::Perl> backend is the default choice
for AnyEvent if it can't find anything else, and is usually a safe
fallback. If you plan to use e.g. L<EV> (L<POE>...), then you need to
include the L<AnyEvent::Impl::EV> (L<AnyEvent::Impl::POE>...) backend as
well.

If you want to handle IRIs or IDNs (L<AnyEvent::Util> punycode and idn
functions), you also need to include C<"AnyEvent/Util/idna.pl"> and
C<"AnyEvent/Util/uts46data.pl">.

Or you can use C<--usepacklists> and specify C<-MAnyEvent> to include
everything.

=item Cairo

See Glib, same problem, same solution.

=item Carp

Carp had (in older versions of perl) a dependency on L<Carp::Heavy>. As of
perl 5.12.2 (maybe earlier), this dependency no longer exists.

=item Config

The F<perl -V> switch (as well as many modules) needs L<Config>, which in
turn might need L<"Config_heavy.pl">. Including the latter gives you
both.

=item Glib

Glib literally requires Glib to be installed already to build - it tries
to fake this by running Glib out of the build directory before being
built. F<staticperl> tries to work around this by forcing C<MAN1PODS> and
C<MAN3PODS> to be empty via the C<PERL_MM_OPT> environment variable.

=item Gtk2

See Pango, same problems, same solution.

=item Pango

In addition to the C<MAN3PODS> problem in Glib, Pango also routes around
L<ExtUtils::MakeMaker> by compiling its files on its own. F<staticperl>
tries to patch L<ExtUtils::MM_Unix> to route around Pango.

=item Term::ReadLine::Perl

Also needs L<Term::ReadLine::readline>, or C<--usepacklists>.

=item URI

URI implements schemes as separate modules - the generic URL scheme is
implemented in L<URI::_generic>, HTTP is implemented in L<URI::http>. If
you need to use any of these schemes, you should include these manually,
or use C<--usepacklists>.

=back

=head2 RECIPES

=over 4

=item Just link everything in

To link just about everything installed in the perl library into a new
perl, try this (the first time this runs it will take a long time, as a
lot of files need to be parsed):

   staticperl mkperl -v --strip ppi --incglob '*'

If you don't mind the extra megabytes, this can be a very effective way of
creating bundles without having to worry about forgetting any modules.

You get even more useful variants of this method by first selecting
everything, and then excluding stuff you are reasonable sure not to need -
L<bigperl|http://staticperl.schmorp.de/bigperl.html> uses this approach.

=item Getting rid of netdb functions

The perl core has lots of netdb functions (C<getnetbyname>, C<getgrent>
and so on) that few applications use. You can avoid compiling them in by
putting the following fragment into a C<preconfigure> hook:

   preconfigure() {
      for sym in \
         d_getgrnam_r d_endgrent d_endgrent_r d_endhent \
         d_endhostent_r d_endnent d_endnetent_r d_endpent \
         d_endprotoent_r d_endpwent d_endpwent_r d_endsent \
         d_endservent_r d_getgrent d_getgrent_r d_getgrgid_r \
         d_getgrnam_r d_gethbyaddr d_gethent d_getsbyport \
         d_gethostbyaddr_r d_gethostbyname_r d_gethostent_r \
         d_getlogin_r d_getnbyaddr d_getnbyname d_getnent \
         d_getnetbyaddr_r d_getnetbyname_r d_getnetent_r \
         d_getpent d_getpbyname d_getpbynumber d_getprotobyname_r \
         d_getprotobynumber_r d_getprotoent_r d_getpwent \
         d_getpwent_r d_getpwnam_r d_getpwuid_r d_getsent \
         d_getservbyname_r d_getservbyport_r d_getservent_r \
         d_getspnam_r d_getsbyname
         # d_gethbyname
      do
         PERL_CONFIGURE="$PERL_CONFIGURE -U$sym"
      done
   }

This mostly gains space when linking statically, as the functions will
likely not be linked in. The gain for dynamically-linked binaries is
smaller.

Also, this leaves C<gethostbyname> in - not only is it actually used
often, the L<Socket> module also exposes it, so leaving it out usually
gains little. Why Socket exposes a C function that is in the core already
is anybody's guess.

=back

=head1 AUTHOR

 Marc Lehmann <schmorp@schmorp.de>
 http://software.schmorp.de/pkg/staticperl.html
